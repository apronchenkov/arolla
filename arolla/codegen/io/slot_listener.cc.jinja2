{# jinja2 file itself is NOT auto generated. -#}
// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: {{ build_target }}
#include <functional>
#include <optional>
{% for hdr in hdrs %}
{{ hdr.include_str }}
{%- endfor %}{# hdr #}
#include "arolla/io/slot_listener.h"
#include "arolla/util/status.h"
#include "arolla/memory/frame.h"
#include "arolla/io/chain_slot_listener.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/qtype/typed_slot.h"
#include "absl/strings/string_view.h"
#include "arolla/util/meta.h"

namespace {
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundSlotListener;
using ::arolla::ConstFramePtr;
using ::arolla::FrameLayout;
using ::arolla::GetQType;
using ::arolla::QTypePtr;
using ::arolla::TypedSlot;
}

{% macro define_output_getter_result_types(leaves, node_numeration) -%}
{% for leaf in leaves %}
using ResultType_{{ node_numeration.leaf2id[leaf] }} = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get{{ node_numeration.leaf2id[leaf] }}(0))>>;
{%- endfor %}{# leaf #}
{%- endmacro -%}{# define_output_getter_result_types -#}

{%- macro define_output_getter(leaves, hierarchical_inputs_type, node_numeration) -%}
// Provides access to the references inside the frame for each leaf.
class OutputGetter {
 public:
  const {{ hierarchical_inputs_type }}* requested_outputs;
  ConstFramePtr frame;

 public:
{% for leaf in leaves %}
  // {{ leaf.comment }}
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get{{ node_numeration.leaf2id[leaf] }}(size_t offset) const {
{%-  if leaf.leaf_accessor.cpp_type %}
{%-    if leaf.is_size %}
    using result_type = {{ leaf.leaf_accessor.cpp_type }};
{%-    else %}
    using result_type = {{ hierarchical_inputs_type }}::value_type<
        {{ leaf.leaf_accessor.cpp_type }}>;
{%-    endif %}{# leaf.is_size #}
{%-  else %}
    using value_type = std::decay_t<decltype(
        {{ leaf.access_for_type("std::declval<Output&>()") }})>;
    using result_type = {{ hierarchical_inputs_type }}::value_type<value_type>;
{%-  endif %}{# leaf.leaf_accessor.cpp_type #}
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[{{ node_numeration.leaf2id[leaf] }}],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }
{% endfor %}{# leaf #}
};

{{ define_output_getter_result_types(leaves, node_numeration) }}
{%- endmacro -%}{# define_output_getter -#}

{% for listener_name, spec in listeners_spec %}
{%-  set impl_namespace = listener_name.namespace + '_' + listener_name.name + 'ImplNamespace' -%}
namespace {{ impl_namespace }} {
namespace {

using Output = {{ spec.output_cls.full_name }};

{% if spec.accessors_list %}
{% include 'slot_listener_accessors.cc.jinja2' %}
{%- endif %}{# spec.accessors_list -#}

{%- set single_value_protopath_leaves = spec.single_value_protopath_tree.leaves() %}
{%- set has_single_value_protopath_leaves = (single_value_protopath_leaves | length) > 0 %}

{%- if has_single_value_protopath_leaves %}

{% include 'slot_listener_single_value_proto.cc.jinja2' %}
{%- endif %}{# has_single_value_protopath_leaves #}

}  // namespace
}  // namespace {{ impl_namespace }}

{{ listener_name.open_namespace_str }}

std::unique_ptr<::arolla::SlotListener<{{ spec.output_cls.full_name }}>>
{{ listener_name.name }}() {
  static auto* impl = ::arolla::ChainSlotListener<{{ spec.output_cls.full_name }}>::Build(
{%- if has_single_value_protopath_leaves %}
      std::make_unique<{{ impl_namespace }}::single_value_protopath::Listener>()
{%-   if spec.accessors_list -%}
,
{%-   endif -%}{# spec.accessors_list #}
{%- endif -%}{# single_value_protopath_leaves #}
{%- if spec.accessors_list %}
      std::make_unique<{{ impl_namespace }}::accessors_listener::Listener>()
{%- endif -%}{# spec.accessors_list #}
  ).value().release();
  return ::arolla::MakeNotOwningSlotListener(impl);
}

{{ listener_name.close_namespace_str }}

{% endfor -%}{# listener_name, spec #}
