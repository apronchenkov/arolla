{# jinja2 file itself is NOT auto generated. -#}
// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: {{ build_target }}

{% from 'input_loader_operators_util.jinja2' import operator_functor_name -%}

#include <memory>

{% for hdr in hdrs %}
{{ hdr.include_str }}
{%- endfor %}{# hdr #}
#include "arolla/qexpr/operator_metadata.h"
#include "arolla/qexpr/optools.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/expr/operator_loader/backend_operator.h"
#include "arolla/expr/registered_expr_operator.h"

{%- macro register_operators_for_shard(loader_name, spec, shard_id) -%}
{%    if shard_id < spec.accessors_collections | length %}
{%      for name, accessor in spec.accessors_collections[shard_id].all_raw_accessors().named_accessors %}
{  // {{ name }}
  static constexpr absl::string_view kOperatorName =
      "{{ cpp.construct_operator_name(loader_name, name) }}";
  {%- set functor_name = operator_functor_name(loader_name, 0, loop.index0, name)  %}

  // Register QExpr operator.
  ASSIGN_OR_RETURN(
      auto qexpr_op, ::arolla::QExprOperatorFromFunction(
          {{ functor_name }}()));
  RETURN_IF_ERROR(
    ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
        kOperatorName,
        qexpr_op));

  // Register Expr operator.
  RETURN_IF_ERROR(
    ::arolla::expr::RegisterOperator(
            kOperatorName, arolla::operator_loader::BackendOperator::Make(
              kOperatorName,
              arolla::expr::ExprOperatorSignature::MakeArgsN(1),
              /*doc=*/kOperatorName,
              /*qtype_constraints=*/{},
              /*qtype_inference_expr=*/arolla::expr::Literal(
                  qexpr_op->signature()->output_type()
              )))
    .status());

  // Register QExpr metadata for codegen.
  ::arolla::QExprOperatorMetadata metadata;
  metadata.name = kOperatorName;
  metadata.build_details.build_target =
      "{{ build_target }}";
  metadata.build_details.op_class =
        R"FUNCTOR_NAME({{ loader_name.namespace }}::{{ functor_name }})FUNCTOR_NAME";
  ::arolla::OpClassDetails op_class_details;
  op_class_details.returns_status_or = false;
  op_class_details.accepts_context = false;
  metadata.build_details.op_class_details = op_class_details;
  metadata.build_details.hdrs = {
      "{{ operator_functors_hdr }}"};
  metadata.build_details.deps = {
      "{{ build_target }}_lib"};
  metadata.input_qtypes = {kInputQtype};
  ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
}
{%      endfor -%}
{%    endif -%}
{%- endmacro %}


{% for loader_name, spec in loaders_spec -%}
{%   set loader_id = loop.index0 -%}
{{   loader_name.open_namespace_str }}
namespace {

// {{ loader_name.full_name }}
absl::Status RegisterIOOperators{{ loader_id }}() {
  const arolla::QTypePtr kInputQtype =
      ::arolla::GetQType<{{ spec.input_cls.full_name }}>();

{%-  filter indent(width=2) -%}
{{ register_operators_for_shard(loader_name, spec, requested_shard_id) }}
{%-   endfilter %}
  return absl::OkStatus();
}

AROLLA_INITIALIZER(.init_fn = RegisterIOOperators{{ loader_id }});

}  // namespace
{{   loader_name.close_namespace_str }}
{% endfor %}
