// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_proto_input_loader

#include <memory>


#include "arolla/codegen/io/multi_loader.h"
#include "arolla/codegen/io/testing/test_proto_qtype.h"
#include "arolla/proto/test.pb.h"
#include "arolla/proto/types.h"
#include "arolla/util/map.h"
#include "arolla/util/text.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace my_namespace_GetProtoLoaderImplNamespace {

using Input = ::testing_namespace::Root;

namespace {
namespace {
namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being loaded.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/15,
        /*kNodeCount=*/20>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:

  // protopath=`BrOkEn_CaSe` name=`/BrOkEn_CaSe`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().broken_case())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[0],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[0]/&` name=`/inners[0]`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using value_type = std::decay_t<decltype(
        (&(std::declval<const Input&>().inners(0))))>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[1],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[0]/a` name=`inners_0__a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).a())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[2],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`private` name=`/private`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().private_())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[3],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x` name=`/x`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable4(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().x())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[4],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/a` name=`inner__a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable5(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inner().a())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[5],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`map_int["a"]` name=`map_int_a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable6(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().map_int().at("a"))>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[6],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`raw_bytes` name=`raw_bytes`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable7(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().raw_bytes())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[7],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`str` name=`str["_"]`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable8(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[8],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_bytes_cord` name=`x_bytes_cord`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable9(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().x_bytes_cord())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[9],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_bytes_string_view` name=`x_bytes_string_view`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable10(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().x_bytes_string_view())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[10],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_enum` name=`x_enum`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable11(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().x_enum())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[11],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_string_cord` name=`x_string_cord`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable12(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[12],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_string_string_view` name=`x_string_string_view`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable13(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[13],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`ys[0]` name=`ys_0`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable14(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().ys(0))>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[14],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

};


using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;
using ResultType_4 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable4(0))>>;
using ResultType_5 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable5(0))>>;
using ResultType_6 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable6(0))>>;
using ResultType_7 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable7(0))>>;
using ResultType_8 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable8(0))>>;
using ResultType_9 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable9(0))>>;
using ResultType_10 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable10(0))>>;
using ResultType_11 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable11(0))>>;
using ResultType_12 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable12(0))>>;
using ResultType_13 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable13(0))>>;
using ResultType_14 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable14(0))>>;

// Set all optional values under the node as missed.
void SetAllOptionalMissed(
    const HierarchicalSingleValueRequestedInputs& requested_inputs,
    FramePtr frame,
    size_t node_intermediate_id) {
  const auto& clear_info =
      requested_inputs.node_optional_clear_infos[node_intermediate_id];
  for (size_t i = clear_info.range_begin; i != clear_info.range_end; ++i) {
     *frame.GetMutable(
         ::arolla::FrameLayout::Slot<bool>::UnsafeSlotFromOffset(
             requested_inputs.requested_offsets[i])) = false;
  }
}

// Traverse the proto and put results for all single values to the frame.
class SlotSetter {
 public:

 void CollectResults(const Input& input, const OutputProvider& outputs) {
   const Input& tmp_4 = input;

    // protopath=`ROOT` fictive
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[2]) {
        return;
      }
      const auto& tmp_2 = tmp_4;
      // protopath=`BrOkEn_CaSe` name=`/BrOkEn_CaSe`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[0];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, broken_case))) {
            outputs.GetMutable0(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable0(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_2.broken_case());
        }
      }();
      // protopath=`inners[0]`
      [&]() {
        if (!outputs.requested_inputs->common.node_requested[0]) {
          return;
        }
        if (!(tmp_2.inners().size() > 0)) {
          SetAllOptionalMissed(
              *outputs.requested_inputs,
              outputs.frame,
              0);
          return;
        }
        const auto& tmp_0 = tmp_2.inners(0);
        // protopath=`inners[0]/&` name=`/inners[0]`
        [&]() {
          if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[1];
              offset != kSkippedOffset) {
            auto* output = outputs.GetMutable1(offset);
            output->present = true;
            output->value = ::arolla::proto::ToArollaCompatibleType(
                (&(tmp_0)));
          }
        }();
        // protopath=`inners[0]/a` name=`inners_0__a`
        [&]() {
          if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[2];
              offset != kSkippedOffset) {
            if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, a))) {
              outputs.GetMutable2(offset)->present = false;
              return;
            }
            auto* output = outputs.GetMutable2(offset);
            output->present = true;
            output->value = ::arolla::proto::ToArollaCompatibleType(
                tmp_0.a());
          }
        }();
      }();
      // protopath=`private` name=`/private`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[3];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, private_))) {
            outputs.GetMutable3(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable3(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_2.private_());
        }
      }();
      // protopath=`x` name=`/x`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[4];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, x))) {
            outputs.GetMutable4(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable4(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_2.x());
        }
      }();
      // protopath=`inner`
      [&]() {
        if (!outputs.requested_inputs->common.node_requested[1]) {
          return;
        }
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, inner))) {
          SetAllOptionalMissed(
              *outputs.requested_inputs,
              outputs.frame,
              1);
          return;
        }
        const auto& tmp_1 = tmp_2.inner();
        // protopath=`inner/a` name=`inner__a`
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[5];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_1, a))) {
            outputs.GetMutable5(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable5(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_1.a());
        }
      }();
      // protopath=`map_int["a"]` name=`map_int_a`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[6];
            offset != kSkippedOffset) {
          if (!(tmp_2.map_int().count("a") > 0)) {
            outputs.GetMutable6(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable6(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_2.map_int().at("a"));
        }
      }();
      // protopath=`raw_bytes` name=`raw_bytes`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[7];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, raw_bytes))) {
            outputs.GetMutable7(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable7(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_2.raw_bytes());
        }
      }();
      // protopath=`str` name=`str["_"]`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[8];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, str))) {
            outputs.GetMutable8(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable8(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_2.str());
        }
      }();
    }();
    // protopath=`ROOT` fictive
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[3]) {
        return;
      }
      const auto& tmp_3 = tmp_4;
      // protopath=`x_bytes_cord` name=`x_bytes_cord`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[9];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_3, x_bytes_cord))) {
            outputs.GetMutable9(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable9(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_3.x_bytes_cord());
        }
      }();
      // protopath=`x_bytes_string_view` name=`x_bytes_string_view`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[10];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_3, x_bytes_string_view))) {
            outputs.GetMutable10(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable10(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_3.x_bytes_string_view());
        }
      }();
      // protopath=`x_enum` name=`x_enum`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[11];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_3, x_enum))) {
            outputs.GetMutable11(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable11(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_3.x_enum());
        }
      }();
      // protopath=`x_string_cord` name=`x_string_cord`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[12];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_3, x_string_cord))) {
            outputs.GetMutable12(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable12(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_3.x_string_cord());
        }
      }();
      // protopath=`x_string_string_view` name=`x_string_string_view`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[13];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_3, x_string_string_view))) {
            outputs.GetMutable13(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable13(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_3.x_string_string_view());
        }
      }();
      // protopath=`ys[0]` name=`ys_0`
      [&]() {
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[14];
            offset != kSkippedOffset) {
          if (!(tmp_3.ys().size() > 0)) {
            outputs.GetMutable14(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable14(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(
              tmp_3.ys(0));
        }
      }();
    }();
  }
};

// InputLoader for all single value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
    : ::arolla::StaticInputLoader<Input>(
        // Use special builder to reduce binary size and stack pressure.
        []() {
          ::arolla::codegen::NamedQTypeVectorBuilder builder;
          builder.AddFromCommonPrefixWithPrevious(
              // /BrOkEn_CaSe
              12,
              R"RL_CODEGEN_DELIM(/BrOkEn_CaSe)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_0>());
          builder.AddFromCommonPrefixWithPrevious(
              // /inners[0]
              10,
              R"RL_CODEGEN_DELIM(inners[0])RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_1>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners_0__a
              11,
              R"RL_CODEGEN_DELIM(inners_0__a)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_2>());
          builder.AddFromCommonPrefixWithPrevious(
              // /private
              8,
              R"RL_CODEGEN_DELIM(/private)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_3>());
          builder.AddFromCommonPrefixWithPrevious(
              // /x
              2,
              R"RL_CODEGEN_DELIM(x)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_4>());
          builder.AddFromCommonPrefixWithPrevious(
              // inner__a
              8,
              R"RL_CODEGEN_DELIM(inner__a)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_5>());
          builder.AddFromCommonPrefixWithPrevious(
              // map_int_a
              9,
              R"RL_CODEGEN_DELIM(map_int_a)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_6>());
          builder.AddFromCommonPrefixWithPrevious(
              // raw_bytes
              9,
              R"RL_CODEGEN_DELIM(raw_bytes)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_7>());
          builder.AddFromCommonPrefixWithPrevious(
              // str["_"]
              8,
              R"RL_CODEGEN_DELIM(str["_"])RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_8>());
          builder.AddFromCommonPrefixWithPrevious(
              // x_bytes_cord
              12,
              R"RL_CODEGEN_DELIM(x_bytes_cord)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_9>());
          builder.AddFromCommonPrefixWithPrevious(
              // x_bytes_string_view
              19,
              R"RL_CODEGEN_DELIM(string_view)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_10>());
          builder.AddFromCommonPrefixWithPrevious(
              // x_enum
              6,
              R"RL_CODEGEN_DELIM(enum)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_11>());
          builder.AddFromCommonPrefixWithPrevious(
              // x_string_cord
              13,
              R"RL_CODEGEN_DELIM(string_cord)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_12>());
          builder.AddFromCommonPrefixWithPrevious(
              // x_string_string_view
              20,
              R"RL_CODEGEN_DELIM(string_view)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_13>());
          builder.AddFromCommonPrefixWithPrevious(
              // ys_0
              4,
              R"RL_CODEGEN_DELIM(ys_0)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_14>());
          return std::move(builder).Build();
        }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(20);
      tree[3] = {1,2};
      tree[7] = {6};
      tree[11] = {0,3,4,5,7,8,9,10};
      tree[18] = {12,13,14,15,16,17};
      tree[19] = {11,18};
      return tree;
    }();
    CreateHierarchicalSingleValueRequestedInputs(
      optional_slots,
      /*size_leaves=*/{  },
      tree,
      inputs.get());
    return BoundInputLoader<Input>([inputs=std::move(*inputs)](
        const Input& input, FramePtr frame, RawBufferFactory*) {
      OutputProvider output_getter{&inputs, frame};
      SlotSetter slot_setter;
      slot_setter.CollectResults(input, output_getter);
      return OkStatus();
    });
  }
};

}  // namespace single_value_protopath

}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>*
GetCollectionInputLoader() {
  static const InputLoader<Input>* impl = ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(static_cast<InputLoader<Input>*>(
            new single_value_protopath::Loader()))
      )->release();
  return impl;
}
}  // namespace


namespace {

constexpr auto GetAllShardsInputLoader =
    ::my_namespace_GetProtoLoaderImplNamespace::GetCollectionInputLoader;

}  // namespace
}  // namespace my_namespace_GetProtoLoaderImplNamespace

namespace my_namespace {

std::unique_ptr<InputLoader<::testing_namespace::Root>>
GetProtoLoader() {
  return MakeNotOwningInputLoader(
      ::my_namespace_GetProtoLoaderImplNamespace::GetAllShardsInputLoader());
}

}  // namespace my_namespace

