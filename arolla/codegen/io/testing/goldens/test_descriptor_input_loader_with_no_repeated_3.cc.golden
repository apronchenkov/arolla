// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_descriptor_input_loader_with_no_repeated

#include <memory>


#include "arolla/codegen/io/multi_loader.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/proto/testing/test.pb.h"
#include "arolla/proto/testing/test_proto3.pb.h"
#include "arolla/util/map.h"
#include "arolla/util/text.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/qtype/base_types.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace my_namespace_GetDescriptorBasedLoaderWithoutRepeatedImplNamespace {

using Input = ::testing_namespace::Root;

namespace shard3 {
namespace {
namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being loaded.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/7,
        /*kNodeCount=*/8>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:

  // protopath=`x_enum` name=`/x_enum`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().x_enum())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[0],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_fixed64` name=`/x_fixed64`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().x_fixed64())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[1],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_float` name=`/x_float`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().x_float())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[2],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_int64` name=`/x_int64`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().x_int64())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[3],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_string_cord` name=`/x_string_cord`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable4(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[4],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_uint32` name=`/x_uint32`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable5(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().x_uint32())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[5],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_uint64` name=`/x_uint64`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable6(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().x_uint64())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[6],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

};


using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;
using ResultType_4 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable4(0))>>;
using ResultType_5 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable5(0))>>;
using ResultType_6 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable6(0))>>;

// Traverse the proto and put results for all single values to the frame.
class SlotSetter {
 public:

 void CollectResults(const Input& input, const OutputProvider& outputs) {
   const Input& tmp_0 = input;

    // protopath=`x_enum` name=`/x_enum`
    [&]() {
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_enum))) {
          outputs.GetMutable0(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable0(offset);
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(
            tmp_0.x_enum());
      }
    }();
    // protopath=`x_fixed64` name=`/x_fixed64`
    [&]() {
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[1];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_fixed64))) {
          outputs.GetMutable1(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable1(offset);
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(
            tmp_0.x_fixed64());
      }
    }();
    // protopath=`x_float` name=`/x_float`
    [&]() {
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[2];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_float))) {
          outputs.GetMutable2(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable2(offset);
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(
            tmp_0.x_float());
      }
    }();
    // protopath=`x_int64` name=`/x_int64`
    [&]() {
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[3];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_int64))) {
          outputs.GetMutable3(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable3(offset);
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(
            tmp_0.x_int64());
      }
    }();
    // protopath=`x_string_cord` name=`/x_string_cord`
    [&]() {
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[4];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_string_cord))) {
          outputs.GetMutable4(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable4(offset);
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(
            tmp_0.x_string_cord());
      }
    }();
    // protopath=`x_uint32` name=`/x_uint32`
    [&]() {
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[5];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_uint32))) {
          outputs.GetMutable5(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable5(offset);
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(
            tmp_0.x_uint32());
      }
    }();
    // protopath=`x_uint64` name=`/x_uint64`
    [&]() {
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[6];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_uint64))) {
          outputs.GetMutable6(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable6(offset);
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(
            tmp_0.x_uint64());
      }
    }();
  }
};

// InputLoader for all single value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
    : ::arolla::StaticInputLoader<Input>(
        // Use special builder to reduce binary size and stack pressure.
        []() {
          ::arolla::codegen::NamedQTypeVectorBuilder builder;
          builder.AddFromCommonPrefixWithPrevious(
              // /x_enum
              7,
              R"RL_CODEGEN_DELIM(/x_enum)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_0>());
          builder.AddFromCommonPrefixWithPrevious(
              // /x_fixed64
              10,
              R"RL_CODEGEN_DELIM(fixed64)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_1>());
          builder.AddFromCommonPrefixWithPrevious(
              // /x_float
              8,
              R"RL_CODEGEN_DELIM(loat)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_2>());
          builder.AddFromCommonPrefixWithPrevious(
              // /x_int64
              8,
              R"RL_CODEGEN_DELIM(int64)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_3>());
          builder.AddFromCommonPrefixWithPrevious(
              // /x_string_cord
              14,
              R"RL_CODEGEN_DELIM(string_cord)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_4>());
          builder.AddFromCommonPrefixWithPrevious(
              // /x_uint32
              9,
              R"RL_CODEGEN_DELIM(uint32)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_5>());
          builder.AddFromCommonPrefixWithPrevious(
              // /x_uint64
              9,
              R"RL_CODEGEN_DELIM(64)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_6>());
          return std::move(builder).Build();
        }()) {}

 private:
  auto CreateProtopathTree() const {
    return []() {
      std::vector<std::vector<size_t>> tree(8);
      tree[7] = {0,1,2,3,4,5,6};
      return tree;
    }();
  }

  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = CreateProtopathTree();
    CreateHierarchicalSingleValueRequestedInputs(
      optional_slots,
      /*size_leaves=*/{  },
      tree,
      inputs.get());
    return BoundInputLoader<Input>([inputs=std::move(inputs)](
        const Input& input, FramePtr frame, RawBufferFactory*) {
      OutputProvider output_getter{inputs.get(), frame};
      SlotSetter slot_setter;
      slot_setter.CollectResults(input, output_getter);
      return OkStatus();
    });
  }
};

}  // namespace single_value_protopath

}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>*
GetCollectionInputLoader() {
  static const InputLoader<Input>* impl = ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(static_cast<InputLoader<Input>*>(
            new single_value_protopath::Loader()))
      )->release();
  return impl;
}
}  // namespace shard3


namespace {

}  // namespace
}  // namespace my_namespace_GetDescriptorBasedLoaderWithoutRepeatedImplNamespace

