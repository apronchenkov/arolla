// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target:
// //arolla/codegen/io/testing:test_sharded_slot_listener_set

#include <functional>
#include <optional>

#include "absl/strings/string_view.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/chain_slot_listener.h"
#include "arolla/io/slot_listener.h"
#include "arolla/memory/frame.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/qtype/typed_slot.h"
#include "arolla/util/meta.h"
#include "arolla/util/status.h"

namespace {
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundSlotListener;
using ::arolla::ChainSlotListener;
using ::arolla::ConstFramePtr;
using ::arolla::FrameLayout;
using ::arolla::GetQType;
using ::arolla::QTypePtr;
using ::arolla::SlotListener;
using ::arolla::TypedSlot;
}  // namespace

namespace aaa_GetShardedListener1ImplNamespace {

using Output = ::std::array<int, 10>;

// Declare other shards defined in the separate cc files.
namespace shard1 {
const SlotListener<Output>* GetCollectionSlotListener();
}  // namespace shard1

namespace {
namespace {
namespace accessors_listener {

template <class Fn>
using accessor_lambda_result_t = std::decay_t<::arolla::meta::head_t<
    typename ::arolla::meta::function_traits<Fn>::arg_types>>;

constexpr auto accessor_lambda_0 = [](auto) {
  return [](int i, ::std::array<int, 10>* out) { (*out)[3] = i; };
}(std::decay<Output>());
using accessor_lambda_0_result_t =
    accessor_lambda_result_t<decltype(accessor_lambda_0)>;
using accessor_lambda_0_has_status =
    std::is_same<typename ::arolla::meta::function_traits<
                     decltype(accessor_lambda_0)>::return_type,
                 absl::Status>;
using output_slot_0_t = FrameLayout::Slot<accessor_lambda_0_result_t>;

const auto* kInputTypesInOrder =
    new std::vector<std::pair<std::string, QTypePtr>>(
        // avoid using initializer_list to reduce stack pressure
        []() {
          std::vector<std::pair<std::string, QTypePtr>> result(1);
          // Note: `result[i] =` is more binary size efficient as
          // `emplace_back`.
          result[0] = {"a3", GetQType<accessor_lambda_0_result_t>()};
          return result;
        }());
const auto* kInputTypes = new absl::flat_hash_map<std::string, QTypePtr>(
    kInputTypesInOrder->begin(), kInputTypesInOrder->end());

constexpr size_t kSkippedOffset = std::numeric_limits<size_t>::max();

struct SlotListenerLambdaCaller {
  size_t offsets[1];
  // true iff at least one slot in the group of size 8 is present
  bool offset_group_present[1] = {false};

  template <class Output>  // templated in order to trigger constexpr if
  Status operator()(ConstFramePtr frame, Output* output) const {
    if (offset_group_present[0]) {
      if (auto offset = offsets[0]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_0_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_0(
              frame.Get(output_slot_0_t::UnsafeSlotFromOffset(offset)),
              output));
        } else {
          accessor_lambda_0(
              frame.Get(output_slot_0_t::UnsafeSlotFromOffset(offset)), output);
        }
      }
    }
    return ::absl::OkStatus();
  }
};

class Listener : public ::arolla::StaticSlotListener<Output> {
 public:
  const absl::flat_hash_map<std::string, QTypePtr>& GetTypes() const override {
    return *kInputTypes;
  }

 private:
  StatusOr<BoundSlotListener<Output>> BindImpl(
      // The slots corresponding to this SlotListener's inputs.
      const absl::flat_hash_map<std::string, TypedSlot>& input_slots)
      const override {
    ASSIGN_OR_RETURN(std::vector<std::optional<TypedSlot>> input_slots_in_order,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(*kInputTypesInOrder,
                                                            input_slots));
    SlotListenerLambdaCaller fn;
    for (size_t i = 0; i != 1; ++i) {
      auto slot = input_slots_in_order[i];
      fn.offsets[i] = slot.has_value() ? slot->byte_offset() : kSkippedOffset;
      if (slot.has_value()) {
        fn.offset_group_present[i / 8] = true;
      }
    }
    return fn;
  }
};

}  // namespace accessors_listener
}  // namespace

const SlotListener<Output>* GetCollectionSlotListener() {
  static const SlotListener<Output>* impl =
      ChainSlotListener<Output>::Build(
          std::make_unique<accessors_listener::Listener>())
          ->release();
  return impl;
}
}  // namespace
}  // namespace aaa_GetShardedListener1ImplNamespace

namespace aaa {
namespace {
std::vector<std::unique_ptr<::arolla::SlotListener<::std::array<int, 10>>>>
GetShardedListener1_Shards() {
  std::vector<std::unique_ptr<::arolla::SlotListener<::std::array<int, 10>>>>
      res;
  res.emplace_back() = MakeNotOwningSlotListener(
      ::aaa_GetShardedListener1ImplNamespace::GetCollectionSlotListener());
  res.emplace_back() =
      MakeNotOwningSlotListener(::aaa_GetShardedListener1ImplNamespace::shard1::
                                    GetCollectionSlotListener());
  return res;
}
}  // namespace

std::unique_ptr<::arolla::SlotListener<::std::array<int, 10>>>
GetShardedListener1() {
  static const SlotListener<
      ::aaa_GetShardedListener1ImplNamespace::Output>* impl =
      ChainSlotListener<::aaa_GetShardedListener1ImplNamespace::Output>::Build(
          GetShardedListener1_Shards())
          .value()
          .release();
  return ::arolla::MakeNotOwningSlotListener(impl);
}

}  // namespace aaa

namespace bbb_GetShardedListener2ImplNamespace {

using Output = ::std::array<float, 5>;

// Declare other shards defined in the separate cc files.
namespace shard1 {
const SlotListener<Output>* GetCollectionSlotListener();
}  // namespace shard1

namespace {
namespace {
namespace accessors_listener {

template <class Fn>
using accessor_lambda_result_t = std::decay_t<::arolla::meta::head_t<
    typename ::arolla::meta::function_traits<Fn>::arg_types>>;

constexpr auto accessor_lambda_0 = [](auto) {
  return [](float i, ::std::array<float, 5>* out) { (*out)[2] = i; };
}(std::decay<Output>());
using accessor_lambda_0_result_t =
    accessor_lambda_result_t<decltype(accessor_lambda_0)>;
using accessor_lambda_0_has_status =
    std::is_same<typename ::arolla::meta::function_traits<
                     decltype(accessor_lambda_0)>::return_type,
                 absl::Status>;
using output_slot_0_t = FrameLayout::Slot<accessor_lambda_0_result_t>;

const auto* kInputTypesInOrder =
    new std::vector<std::pair<std::string, QTypePtr>>(
        // avoid using initializer_list to reduce stack pressure
        []() {
          std::vector<std::pair<std::string, QTypePtr>> result(1);
          // Note: `result[i] =` is more binary size efficient as
          // `emplace_back`.
          result[0] = {"a2", GetQType<accessor_lambda_0_result_t>()};
          return result;
        }());
const auto* kInputTypes = new absl::flat_hash_map<std::string, QTypePtr>(
    kInputTypesInOrder->begin(), kInputTypesInOrder->end());

constexpr size_t kSkippedOffset = std::numeric_limits<size_t>::max();

struct SlotListenerLambdaCaller {
  size_t offsets[1];
  // true iff at least one slot in the group of size 8 is present
  bool offset_group_present[1] = {false};

  template <class Output>  // templated in order to trigger constexpr if
  Status operator()(ConstFramePtr frame, Output* output) const {
    if (offset_group_present[0]) {
      if (auto offset = offsets[0]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_0_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_0(
              frame.Get(output_slot_0_t::UnsafeSlotFromOffset(offset)),
              output));
        } else {
          accessor_lambda_0(
              frame.Get(output_slot_0_t::UnsafeSlotFromOffset(offset)), output);
        }
      }
    }
    return ::absl::OkStatus();
  }
};

class Listener : public ::arolla::StaticSlotListener<Output> {
 public:
  const absl::flat_hash_map<std::string, QTypePtr>& GetTypes() const override {
    return *kInputTypes;
  }

 private:
  StatusOr<BoundSlotListener<Output>> BindImpl(
      // The slots corresponding to this SlotListener's inputs.
      const absl::flat_hash_map<std::string, TypedSlot>& input_slots)
      const override {
    ASSIGN_OR_RETURN(std::vector<std::optional<TypedSlot>> input_slots_in_order,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(*kInputTypesInOrder,
                                                            input_slots));
    SlotListenerLambdaCaller fn;
    for (size_t i = 0; i != 1; ++i) {
      auto slot = input_slots_in_order[i];
      fn.offsets[i] = slot.has_value() ? slot->byte_offset() : kSkippedOffset;
      if (slot.has_value()) {
        fn.offset_group_present[i / 8] = true;
      }
    }
    return fn;
  }
};

}  // namespace accessors_listener
}  // namespace

const SlotListener<Output>* GetCollectionSlotListener() {
  static const SlotListener<Output>* impl =
      ChainSlotListener<Output>::Build(
          std::make_unique<accessors_listener::Listener>())
          ->release();
  return impl;
}
}  // namespace
}  // namespace bbb_GetShardedListener2ImplNamespace

namespace bbb {
namespace {
std::vector<std::unique_ptr<::arolla::SlotListener<::std::array<float, 5>>>>
GetShardedListener2_Shards() {
  std::vector<std::unique_ptr<::arolla::SlotListener<::std::array<float, 5>>>>
      res;
  res.emplace_back() = MakeNotOwningSlotListener(
      ::bbb_GetShardedListener2ImplNamespace::GetCollectionSlotListener());
  res.emplace_back() =
      MakeNotOwningSlotListener(::bbb_GetShardedListener2ImplNamespace::shard1::
                                    GetCollectionSlotListener());
  return res;
}
}  // namespace

std::unique_ptr<::arolla::SlotListener<::std::array<float, 5>>>
GetShardedListener2() {
  static const SlotListener<
      ::bbb_GetShardedListener2ImplNamespace::Output>* impl =
      ChainSlotListener<::bbb_GetShardedListener2ImplNamespace::Output>::Build(
          GetShardedListener2_Shards())
          .value()
          .release();
  return ::arolla::MakeNotOwningSlotListener(impl);
}

}  // namespace bbb
