// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target:
// //arolla/codegen/io/testing:test_descriptor_input_loader_with_no_repeated

#include "arolla/codegen/io/multi_loader.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/proto/test.pb.h"
#include "arolla/proto/test_proto3.pb.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/util/map.h"
#include "arolla/util/text.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::InputLoaderPtr;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace my_namespace_GetDescriptorBasedLoaderWithoutRepeatedImplNamespace {
namespace {

using Input = ::testing_namespace::Root;

namespace shard0 {
namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;
using ::arolla::codegen::io::NamedTypesBuilder;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being loaded.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/5,
        /*kNodeCount=*/8>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:
  // protopath=`BrOkEn_CaSe` name=`/BrOkEn_CaSe`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().broken_case())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[0], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`inner/a` name=`/inner/a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().inner().a())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[1], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`inner/bytes_string_view` name=`/inner/bytes_string_view`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using value_type = std::decay_t<
        decltype(std::declval<const Input&>().inner().bytes_string_view())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[2], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`inner/inner2/z` name=`/inner/inner2/z`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type = std::decay_t<
        decltype(std::declval<const Input&>().inner().inner2().z())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[3], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`inner/raw_bytes` name=`/inner/raw_bytes`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable4(size_t offset) const {
    using value_type = std::decay_t<
        decltype(std::declval<const Input&>().inner().raw_bytes())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[4], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }
};

using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;
using ResultType_4 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable4(0))>>;

// Set all optional values under the node as missed.
void SetAllOptionalMissed(
    const HierarchicalSingleValueRequestedInputs& requested_inputs,
    FramePtr frame, size_t node_intermediate_id) {
  const auto& clear_info =
      requested_inputs.node_optional_clear_infos[node_intermediate_id];
  for (size_t i = clear_info.range_begin; i != clear_info.range_end; ++i) {
    *frame.GetMutable(::arolla::FrameLayout::Slot<bool>::UnsafeSlotFromOffset(
        requested_inputs.requested_offsets[i])) = false;
  }
}

// Traverse the proto and put results for all single values to the frame.
class SlotSetter {
 public:
  void CollectResults(const Input& input, const OutputProvider& outputs) {
    const Input& tmp_2 = input;

    // protopath=`BrOkEn_CaSe` name=`/BrOkEn_CaSe`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, broken_case))) {
          outputs.GetMutable0(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable0(offset);
        output->present = true;
        output->value = tmp_2.broken_case();
      }
    }();
    // protopath=`inner`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[1]) {
        return;
      }
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, inner))) {
        SetAllOptionalMissed(*outputs.requested_inputs, outputs.frame, 1);
        return;
      }
      const auto& tmp_1 = tmp_2.inner();
      // protopath=`inner/a` name=`/inner/a`
      [&]() {
        if (size_t offset =
                outputs.requested_inputs->common.leaf_frame_offsets[1];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_1, a))) {
            outputs.GetMutable1(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable1(offset);
          output->present = true;
          output->value = tmp_1.a();
        }
      }();
      // protopath=`inner/bytes_string_view` name=`/inner/bytes_string_view`
      [&]() {
        if (size_t offset =
                outputs.requested_inputs->common.leaf_frame_offsets[2];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_1, bytes_string_view))) {
            outputs.GetMutable2(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable2(offset);
          output->present = true;
          output->value = tmp_1.bytes_string_view();
        }
      }();
      // protopath=`inner/inner2`
      [&]() {
        if (!outputs.requested_inputs->common.node_requested[0]) {
          return;
        }
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_1, inner2))) {
          SetAllOptionalMissed(*outputs.requested_inputs, outputs.frame, 0);
          return;
        }
        const auto& tmp_0 = tmp_1.inner2();
        // protopath=`inner/inner2/z` name=`/inner/inner2/z`
        if (size_t offset =
                outputs.requested_inputs->common.leaf_frame_offsets[3];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, z))) {
            outputs.GetMutable3(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable3(offset);
          output->present = true;
          output->value = tmp_0.z();
        }
      }();
      // protopath=`inner/raw_bytes` name=`/inner/raw_bytes`
      [&]() {
        if (size_t offset =
                outputs.requested_inputs->common.leaf_frame_offsets[4];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_1, raw_bytes))) {
            outputs.GetMutable4(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable4(offset);
          output->present = true;
          output->value = tmp_1.raw_bytes();
        }
      }();
    }();
  }
};

// InputLoader for all single value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
      : ::arolla::StaticInputLoader<Input>(
            // use special builder to reduce binary size and stack pressure
            []() {
              NamedTypesBuilder builder;
              builder.Add(R"RL_CODEGEN_DELIM(/BrOkEn_CaSe)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_0>());
              builder.Add(R"RL_CODEGEN_DELIM(/inner/a)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_1>());
              builder.Add(
                  R"RL_CODEGEN_DELIM(/inner/bytes_string_view)RL_CODEGEN_DELIM",
                  ::arolla::GetQType<ResultType_2>());
              builder.Add(R"RL_CODEGEN_DELIM(/inner/inner2/z)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_3>());
              builder.Add(R"RL_CODEGEN_DELIM(/inner/raw_bytes)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_4>());
              return std::move(builder).Build();
            }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(
        auto optional_slots,
        ::arolla::MaybeFindSlotsAndVerifyTypes(types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(8);
      tree[4] = {3};
      tree[6] = {1, 2, 4, 5};
      tree[7] = {0, 6};
      return tree;
    }();
    CreateHierarchicalSingleValueRequestedInputs(optional_slots,
                                                 /*size_leaves=*/{}, tree,
                                                 inputs.get());
    return BoundInputLoader<Input>(
        [inputs = std::move(*inputs)](const Input& input, FramePtr frame,
                                      RawBufferFactory*) {
          OutputProvider output_getter{&inputs, frame};
          SlotSetter slot_setter;
          slot_setter.CollectResults(input, output_getter);
          return OkStatus();
        });
  }
};

}  // namespace single_value_protopath

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(
              static_cast<const InputLoader<Input>*>(
                  new single_value_protopath::Loader())))
          ->release();
  return impl;
}
}  // namespace shard0
namespace shard1 {
namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;
using ::arolla::codegen::io::NamedTypesBuilder;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being loaded.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/5,
        /*kNodeCount=*/8>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:
  // protopath=`inner/str` name=`/inner/str`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<::arolla::Text>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[0], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`inner/str_string_view` name=`/inner/str_string_view`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<::arolla::Text>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[1], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`private` name=`/private`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().private_())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[2], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`proto3/non_optional_i32` name=`/proto3/non_optional_i32`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type = std::decay_t<
        decltype(std::declval<const Input&>().proto3().non_optional_i32())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[3], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`raw_bytes` name=`/raw_bytes`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable4(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().raw_bytes())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[4], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }
};

using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;
using ResultType_4 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable4(0))>>;

// Set all optional values under the node as missed.
void SetAllOptionalMissed(
    const HierarchicalSingleValueRequestedInputs& requested_inputs,
    FramePtr frame, size_t node_intermediate_id) {
  const auto& clear_info =
      requested_inputs.node_optional_clear_infos[node_intermediate_id];
  for (size_t i = clear_info.range_begin; i != clear_info.range_end; ++i) {
    *frame.GetMutable(::arolla::FrameLayout::Slot<bool>::UnsafeSlotFromOffset(
        requested_inputs.requested_offsets[i])) = false;
  }
}

// Traverse the proto and put results for all single values to the frame.
class SlotSetter {
 public:
  void CollectResults(const Input& input, const OutputProvider& outputs) {
    const Input& tmp_2 = input;

    // protopath=`inner`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[0]) {
        return;
      }
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, inner))) {
        SetAllOptionalMissed(*outputs.requested_inputs, outputs.frame, 0);
        return;
      }
      const auto& tmp_0 = tmp_2.inner();
      // protopath=`inner/str` name=`/inner/str`
      [&]() {
        if (size_t offset =
                outputs.requested_inputs->common.leaf_frame_offsets[0];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, str))) {
            outputs.GetMutable0(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable0(offset);
          output->present = true;
          output->value = tmp_0.str();
        }
      }();
      // protopath=`inner/str_string_view` name=`/inner/str_string_view`
      [&]() {
        if (size_t offset =
                outputs.requested_inputs->common.leaf_frame_offsets[1];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, str_string_view))) {
            outputs.GetMutable1(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable1(offset);
          output->present = true;
          output->value = tmp_0.str_string_view();
        }
      }();
    }();
    // protopath=`private` name=`/private`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[2];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, private_))) {
          outputs.GetMutable2(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable2(offset);
        output->present = true;
        output->value = tmp_2.private_();
      }
    }();
    // protopath=`proto3`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[1]) {
        return;
      }
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, proto3))) {
        SetAllOptionalMissed(*outputs.requested_inputs, outputs.frame, 1);
        return;
      }
      const auto& tmp_1 = tmp_2.proto3();
      // protopath=`proto3/non_optional_i32` name=`/proto3/non_optional_i32`
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[3];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_1, non_optional_i32))) {
          outputs.GetMutable3(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable3(offset);
        output->present = true;
        output->value = tmp_1.non_optional_i32();
      }
    }();
    // protopath=`raw_bytes` name=`/raw_bytes`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[4];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, raw_bytes))) {
          outputs.GetMutable4(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable4(offset);
        output->present = true;
        output->value = tmp_2.raw_bytes();
      }
    }();
  }
};

// InputLoader for all single value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
      : ::arolla::StaticInputLoader<Input>(
            // use special builder to reduce binary size and stack pressure
            []() {
              NamedTypesBuilder builder;
              builder.Add(R"RL_CODEGEN_DELIM(/inner/str)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_0>());
              builder.Add(
                  R"RL_CODEGEN_DELIM(/inner/str_string_view)RL_CODEGEN_DELIM",
                  ::arolla::GetQType<ResultType_1>());
              builder.Add(R"RL_CODEGEN_DELIM(/private)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_2>());
              builder.Add(
                  R"RL_CODEGEN_DELIM(/proto3/non_optional_i32)RL_CODEGEN_DELIM",
                  ::arolla::GetQType<ResultType_3>());
              builder.Add(R"RL_CODEGEN_DELIM(/raw_bytes)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_4>());
              return std::move(builder).Build();
            }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(
        auto optional_slots,
        ::arolla::MaybeFindSlotsAndVerifyTypes(types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(8);
      tree[2] = {0, 1};
      tree[5] = {4};
      tree[7] = {2, 3, 5, 6};
      return tree;
    }();
    CreateHierarchicalSingleValueRequestedInputs(optional_slots,
                                                 /*size_leaves=*/{}, tree,
                                                 inputs.get());
    return BoundInputLoader<Input>(
        [inputs = std::move(*inputs)](const Input& input, FramePtr frame,
                                      RawBufferFactory*) {
          OutputProvider output_getter{&inputs, frame};
          SlotSetter slot_setter;
          slot_setter.CollectResults(input, output_getter);
          return OkStatus();
        });
  }
};

}  // namespace single_value_protopath

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(
              static_cast<const InputLoader<Input>*>(
                  new single_value_protopath::Loader())))
          ->release();
  return impl;
}
}  // namespace shard1
namespace shard2 {
namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;
using ::arolla::codegen::io::NamedTypesBuilder;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being loaded.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/5,
        /*kNodeCount=*/6>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:
  // protopath=`str` name=`/str`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<::arolla::Text>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[0], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x` name=`/x`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using value_type = std::decay_t<decltype(std::declval<const Input&>().x())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[1], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x0` name=`/x0`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x0())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[2], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x1` name=`/x1`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x1())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[3], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x2` name=`/x2`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable4(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x2())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[4], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }
};

using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;
using ResultType_4 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable4(0))>>;

// Traverse the proto and put results for all single values to the frame.
class SlotSetter {
 public:
  void CollectResults(const Input& input, const OutputProvider& outputs) {
    const Input& tmp_0 = input;

    // protopath=`str` name=`/str`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, str))) {
          outputs.GetMutable0(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable0(offset);
        output->present = true;
        output->value = tmp_0.str();
      }
    }();
    // protopath=`x` name=`/x`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[1];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x))) {
          outputs.GetMutable1(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable1(offset);
        output->present = true;
        output->value = tmp_0.x();
      }
    }();
    // protopath=`x0` name=`/x0`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[2];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x0))) {
          outputs.GetMutable2(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable2(offset);
        output->present = true;
        output->value = tmp_0.x0();
      }
    }();
    // protopath=`x1` name=`/x1`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[3];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x1))) {
          outputs.GetMutable3(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable3(offset);
        output->present = true;
        output->value = tmp_0.x1();
      }
    }();
    // protopath=`x2` name=`/x2`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[4];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x2))) {
          outputs.GetMutable4(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable4(offset);
        output->present = true;
        output->value = tmp_0.x2();
      }
    }();
  }
};

// InputLoader for all single value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
      : ::arolla::StaticInputLoader<Input>(
            // use special builder to reduce binary size and stack pressure
            []() {
              NamedTypesBuilder builder;
              builder.Add(R"RL_CODEGEN_DELIM(/str)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_0>());
              builder.Add(R"RL_CODEGEN_DELIM(/x)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_1>());
              builder.Add(R"RL_CODEGEN_DELIM(/x0)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_2>());
              builder.Add(R"RL_CODEGEN_DELIM(/x1)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_3>());
              builder.Add(R"RL_CODEGEN_DELIM(/x2)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_4>());
              return std::move(builder).Build();
            }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(
        auto optional_slots,
        ::arolla::MaybeFindSlotsAndVerifyTypes(types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(6);
      tree[5] = {0, 1, 2, 3, 4};
      return tree;
    }();
    CreateHierarchicalSingleValueRequestedInputs(optional_slots,
                                                 /*size_leaves=*/{}, tree,
                                                 inputs.get());
    return BoundInputLoader<Input>(
        [inputs = std::move(*inputs)](const Input& input, FramePtr frame,
                                      RawBufferFactory*) {
          OutputProvider output_getter{&inputs, frame};
          SlotSetter slot_setter;
          slot_setter.CollectResults(input, output_getter);
          return OkStatus();
        });
  }
};

}  // namespace single_value_protopath

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(
              static_cast<const InputLoader<Input>*>(
                  new single_value_protopath::Loader())))
          ->release();
  return impl;
}
}  // namespace shard2
namespace shard3 {
namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;
using ::arolla::codegen::io::NamedTypesBuilder;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being loaded.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/4,
        /*kNodeCount=*/5>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:
  // protopath=`x3` name=`/x3`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x3())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[0], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x4` name=`/x4`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x4())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[1], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x5` name=`/x5`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x5())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[2], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x6` name=`/x6`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x6())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[3], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }
};

using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;

// Traverse the proto and put results for all single values to the frame.
class SlotSetter {
 public:
  void CollectResults(const Input& input, const OutputProvider& outputs) {
    const Input& tmp_0 = input;

    // protopath=`x3` name=`/x3`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x3))) {
          outputs.GetMutable0(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable0(offset);
        output->present = true;
        output->value = tmp_0.x3();
      }
    }();
    // protopath=`x4` name=`/x4`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[1];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x4))) {
          outputs.GetMutable1(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable1(offset);
        output->present = true;
        output->value = tmp_0.x4();
      }
    }();
    // protopath=`x5` name=`/x5`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[2];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x5))) {
          outputs.GetMutable2(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable2(offset);
        output->present = true;
        output->value = tmp_0.x5();
      }
    }();
    // protopath=`x6` name=`/x6`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[3];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x6))) {
          outputs.GetMutable3(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable3(offset);
        output->present = true;
        output->value = tmp_0.x6();
      }
    }();
  }
};

// InputLoader for all single value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
      : ::arolla::StaticInputLoader<Input>(
            // use special builder to reduce binary size and stack pressure
            []() {
              NamedTypesBuilder builder;
              builder.Add(R"RL_CODEGEN_DELIM(/x3)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_0>());
              builder.Add(R"RL_CODEGEN_DELIM(/x4)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_1>());
              builder.Add(R"RL_CODEGEN_DELIM(/x5)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_2>());
              builder.Add(R"RL_CODEGEN_DELIM(/x6)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_3>());
              return std::move(builder).Build();
            }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(
        auto optional_slots,
        ::arolla::MaybeFindSlotsAndVerifyTypes(types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(5);
      tree[4] = {0, 1, 2, 3};
      return tree;
    }();
    CreateHierarchicalSingleValueRequestedInputs(optional_slots,
                                                 /*size_leaves=*/{}, tree,
                                                 inputs.get());
    return BoundInputLoader<Input>(
        [inputs = std::move(*inputs)](const Input& input, FramePtr frame,
                                      RawBufferFactory*) {
          OutputProvider output_getter{&inputs, frame};
          SlotSetter slot_setter;
          slot_setter.CollectResults(input, output_getter);
          return OkStatus();
        });
  }
};

}  // namespace single_value_protopath

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(
              static_cast<const InputLoader<Input>*>(
                  new single_value_protopath::Loader())))
          ->release();
  return impl;
}
}  // namespace shard3
namespace shard4 {
namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;
using ::arolla::codegen::io::NamedTypesBuilder;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being loaded.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/4,
        /*kNodeCount=*/5>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:
  // protopath=`x7` name=`/x7`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x7())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[0], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x8` name=`/x8`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x8())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[1], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x9` name=`/x9`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x9())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[2], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x_bytes_string_view` name=`/x_bytes_string_view`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type = std::decay_t<
        decltype(std::declval<const Input&>().x_bytes_string_view())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[3], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }
};

using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;

// Traverse the proto and put results for all single values to the frame.
class SlotSetter {
 public:
  void CollectResults(const Input& input, const OutputProvider& outputs) {
    const Input& tmp_0 = input;

    // protopath=`x7` name=`/x7`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x7))) {
          outputs.GetMutable0(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable0(offset);
        output->present = true;
        output->value = tmp_0.x7();
      }
    }();
    // protopath=`x8` name=`/x8`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[1];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x8))) {
          outputs.GetMutable1(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable1(offset);
        output->present = true;
        output->value = tmp_0.x8();
      }
    }();
    // protopath=`x9` name=`/x9`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[2];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x9))) {
          outputs.GetMutable2(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable2(offset);
        output->present = true;
        output->value = tmp_0.x9();
      }
    }();
    // protopath=`x_bytes_string_view` name=`/x_bytes_string_view`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[3];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_bytes_string_view))) {
          outputs.GetMutable3(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable3(offset);
        output->present = true;
        output->value = tmp_0.x_bytes_string_view();
      }
    }();
  }
};

// InputLoader for all single value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
      : ::arolla::StaticInputLoader<Input>(
            // use special builder to reduce binary size and stack pressure
            []() {
              NamedTypesBuilder builder;
              builder.Add(R"RL_CODEGEN_DELIM(/x7)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_0>());
              builder.Add(R"RL_CODEGEN_DELIM(/x8)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_1>());
              builder.Add(R"RL_CODEGEN_DELIM(/x9)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_2>());
              builder.Add(
                  R"RL_CODEGEN_DELIM(/x_bytes_string_view)RL_CODEGEN_DELIM",
                  ::arolla::GetQType<ResultType_3>());
              return std::move(builder).Build();
            }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(
        auto optional_slots,
        ::arolla::MaybeFindSlotsAndVerifyTypes(types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(5);
      tree[4] = {0, 1, 2, 3};
      return tree;
    }();
    CreateHierarchicalSingleValueRequestedInputs(optional_slots,
                                                 /*size_leaves=*/{}, tree,
                                                 inputs.get());
    return BoundInputLoader<Input>(
        [inputs = std::move(*inputs)](const Input& input, FramePtr frame,
                                      RawBufferFactory*) {
          OutputProvider output_getter{&inputs, frame};
          SlotSetter slot_setter;
          slot_setter.CollectResults(input, output_getter);
          return OkStatus();
        });
  }
};

}  // namespace single_value_protopath

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(
              static_cast<const InputLoader<Input>*>(
                  new single_value_protopath::Loader())))
          ->release();
  return impl;
}
}  // namespace shard4
namespace shard5 {
namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;
using ::arolla::codegen::io::NamedTypesBuilder;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being loaded.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/4,
        /*kNodeCount=*/5>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:
  // protopath=`x_double` name=`/x_double`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x_double())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[0], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x_enum` name=`/x_enum`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x_enum())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[1], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x_fixed64` name=`/x_fixed64`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x_fixed64())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[2], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x_float` name=`/x_float`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x_float())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[3], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }
};

using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;

// Traverse the proto and put results for all single values to the frame.
class SlotSetter {
 public:
  void CollectResults(const Input& input, const OutputProvider& outputs) {
    const Input& tmp_0 = input;

    // protopath=`x_double` name=`/x_double`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_double))) {
          outputs.GetMutable0(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable0(offset);
        output->present = true;
        output->value = tmp_0.x_double();
      }
    }();
    // protopath=`x_enum` name=`/x_enum`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[1];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_enum))) {
          outputs.GetMutable1(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable1(offset);
        output->present = true;
        output->value = tmp_0.x_enum();
      }
    }();
    // protopath=`x_fixed64` name=`/x_fixed64`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[2];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_fixed64))) {
          outputs.GetMutable2(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable2(offset);
        output->present = true;
        output->value = tmp_0.x_fixed64();
      }
    }();
    // protopath=`x_float` name=`/x_float`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[3];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_float))) {
          outputs.GetMutable3(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable3(offset);
        output->present = true;
        output->value = tmp_0.x_float();
      }
    }();
  }
};

// InputLoader for all single value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
      : ::arolla::StaticInputLoader<Input>(
            // use special builder to reduce binary size and stack pressure
            []() {
              NamedTypesBuilder builder;
              builder.Add(R"RL_CODEGEN_DELIM(/x_double)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_0>());
              builder.Add(R"RL_CODEGEN_DELIM(/x_enum)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_1>());
              builder.Add(R"RL_CODEGEN_DELIM(/x_fixed64)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_2>());
              builder.Add(R"RL_CODEGEN_DELIM(/x_float)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_3>());
              return std::move(builder).Build();
            }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(
        auto optional_slots,
        ::arolla::MaybeFindSlotsAndVerifyTypes(types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(5);
      tree[4] = {0, 1, 2, 3};
      return tree;
    }();
    CreateHierarchicalSingleValueRequestedInputs(optional_slots,
                                                 /*size_leaves=*/{}, tree,
                                                 inputs.get());
    return BoundInputLoader<Input>(
        [inputs = std::move(*inputs)](const Input& input, FramePtr frame,
                                      RawBufferFactory*) {
          OutputProvider output_getter{&inputs, frame};
          SlotSetter slot_setter;
          slot_setter.CollectResults(input, output_getter);
          return OkStatus();
        });
  }
};

}  // namespace single_value_protopath

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(
              static_cast<const InputLoader<Input>*>(
                  new single_value_protopath::Loader())))
          ->release();
  return impl;
}
}  // namespace shard5
namespace shard6 {
namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;
using ::arolla::codegen::io::NamedTypesBuilder;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being loaded.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/4,
        /*kNodeCount=*/5>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:
  // protopath=`x_int64` name=`/x_int64`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x_int64())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[0], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x_string_string_view` name=`/x_string_string_view`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<::arolla::Text>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[1], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x_uint32` name=`/x_uint32`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x_uint32())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[2], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x_uint64` name=`/x_uint64`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().x_uint64())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[3], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }
};

using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;

// Traverse the proto and put results for all single values to the frame.
class SlotSetter {
 public:
  void CollectResults(const Input& input, const OutputProvider& outputs) {
    const Input& tmp_0 = input;

    // protopath=`x_int64` name=`/x_int64`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_int64))) {
          outputs.GetMutable0(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable0(offset);
        output->present = true;
        output->value = tmp_0.x_int64();
      }
    }();
    // protopath=`x_string_string_view` name=`/x_string_string_view`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[1];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_string_string_view))) {
          outputs.GetMutable1(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable1(offset);
        output->present = true;
        output->value = tmp_0.x_string_string_view();
      }
    }();
    // protopath=`x_uint32` name=`/x_uint32`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[2];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_uint32))) {
          outputs.GetMutable2(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable2(offset);
        output->present = true;
        output->value = tmp_0.x_uint32();
      }
    }();
    // protopath=`x_uint64` name=`/x_uint64`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[3];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, x_uint64))) {
          outputs.GetMutable3(offset)->present = false;
          return;
        }
        auto* output = outputs.GetMutable3(offset);
        output->present = true;
        output->value = tmp_0.x_uint64();
      }
    }();
  }
};

// InputLoader for all single value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
      : ::arolla::StaticInputLoader<Input>(
            // use special builder to reduce binary size and stack pressure
            []() {
              NamedTypesBuilder builder;
              builder.Add(R"RL_CODEGEN_DELIM(/x_int64)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_0>());
              builder.Add(
                  R"RL_CODEGEN_DELIM(/x_string_string_view)RL_CODEGEN_DELIM",
                  ::arolla::GetQType<ResultType_1>());
              builder.Add(R"RL_CODEGEN_DELIM(/x_uint32)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_2>());
              builder.Add(R"RL_CODEGEN_DELIM(/x_uint64)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_3>());
              return std::move(builder).Build();
            }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(
        auto optional_slots,
        ::arolla::MaybeFindSlotsAndVerifyTypes(types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(5);
      tree[4] = {0, 1, 2, 3};
      return tree;
    }();
    CreateHierarchicalSingleValueRequestedInputs(optional_slots,
                                                 /*size_leaves=*/{}, tree,
                                                 inputs.get());
    return BoundInputLoader<Input>(
        [inputs = std::move(*inputs)](const Input& input, FramePtr frame,
                                      RawBufferFactory*) {
          OutputProvider output_getter{&inputs, frame};
          SlotSetter slot_setter;
          slot_setter.CollectResults(input, output_getter);
          return OkStatus();
        });
  }
};

}  // namespace single_value_protopath

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(
              static_cast<const InputLoader<Input>*>(
                  new single_value_protopath::Loader())))
          ->release();
  return impl;
}
}  // namespace shard6

// Returns InputLoaders for each shard.
std::vector<::arolla::InputLoaderPtr<Input>> GetShardInputLoaders() {
  std::vector<::arolla::InputLoaderPtr<Input>> res;

  res.emplace_back() =
      MakeNotOwningInputLoader(shard0::GetCollectionInputLoader());
  res.emplace_back() =
      MakeNotOwningInputLoader(shard1::GetCollectionInputLoader());
  res.emplace_back() =
      MakeNotOwningInputLoader(shard2::GetCollectionInputLoader());
  res.emplace_back() =
      MakeNotOwningInputLoader(shard3::GetCollectionInputLoader());
  res.emplace_back() =
      MakeNotOwningInputLoader(shard4::GetCollectionInputLoader());
  res.emplace_back() =
      MakeNotOwningInputLoader(shard5::GetCollectionInputLoader());
  res.emplace_back() =
      MakeNotOwningInputLoader(shard6::GetCollectionInputLoader());
  return res;
}

// Returns ChainInputLoader with all shards.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(GetShardInputLoaders()).value().release();
  return impl;
}

}  // namespace
}  // namespace
   // my_namespace_GetDescriptorBasedLoaderWithoutRepeatedImplNamespace

namespace my_namespace {

::arolla::InputLoaderPtr<::testing_namespace::Root>
GetDescriptorBasedLoaderWithoutRepeated() {
  return MakeNotOwningInputLoader(
      ::my_namespace_GetDescriptorBasedLoaderWithoutRepeatedImplNamespace::
          GetCollectionInputLoader());
}
std::vector<::arolla::InputLoaderPtr<::testing_namespace::Root>>
GetDescriptorBasedLoaderWithoutRepeated_Shards() {
  return ::my_namespace_GetDescriptorBasedLoaderWithoutRepeatedImplNamespace::
      GetShardInputLoaders();
}

}  // namespace my_namespace
