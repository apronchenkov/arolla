// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target:
// //arolla/codegen/io/testing:test_empty_slot_listener

#include <functional>
#include <optional>

#include "absl/strings/string_view.h"
#include "arolla/io/chain_slot_listener.h"
#include "arolla/io/slot_listener.h"
#include "arolla/memory/frame.h"
#include "arolla/proto/test.pb.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/qtype/typed_slot.h"
#include "arolla/util/meta.h"
#include "arolla/util/status.h"

namespace {
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundSlotListener;
using ::arolla::ChainSlotListener;
using ::arolla::ConstFramePtr;
using ::arolla::FrameLayout;
using ::arolla::GetQType;
using ::arolla::QTypePtr;
using ::arolla::SlotListener;
using ::arolla::TypedSlot;
}  // namespace

namespace my_namespace_GetEmptySlotListenerImplNamespace {

using Output = ::testing_namespace::Root;

namespace {
namespace {}  // namespace

const SlotListener<Output>* GetCollectionSlotListener() {
  static const SlotListener<Output>* impl =
      ChainSlotListener<Output>::Build()->release();
  return impl;
}
}  // namespace
}  // namespace my_namespace_GetEmptySlotListenerImplNamespace

namespace my_namespace {

std::unique_ptr<::arolla::SlotListener<::testing_namespace::Root>>
GetEmptySlotListener() {
  return MakeNotOwningSlotListener(
      ::my_namespace_GetEmptySlotListenerImplNamespace::
          GetCollectionSlotListener());
}

}  // namespace my_namespace
