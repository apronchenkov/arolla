// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target:
// //arolla/codegen/io/testing:test_input_loader_operators_set

#include <memory>

#include "arolla/codegen/io/testing/test_input_loader_operators_set.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/expr/lambda_expr_operator.h"
#include "arolla/expr/operator_loader/backend_operator.h"
#include "arolla/expr/registered_expr_operator.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/qexpr/operator_metadata.h"
#include "arolla/qexpr/optools.h"
#include "arolla/qtype/base_types.h"

namespace my_namespace {
namespace {

// ::my_namespace::LoadFromInt
absl::Status RegisterIOOperators0() {
  const arolla::QTypePtr kInputQtype = ::arolla::GetQType<int>();
  // Register Expr operator for input QType.
  static constexpr absl::string_view kQTypeOperatorName =
      "_G_Gmy_Rnamespace_G_GLoadFromInt_G_GQTYPE_G_G_R_RGetInputQType";
  RETURN_IF_ERROR(::arolla::expr::RegisterOperator(
                      kQTypeOperatorName,
                      arolla::expr::LambdaOperator::Make(
                          kQTypeOperatorName,
                          arolla::expr::ExprOperatorSignature::MakeArgsN(0),
                          arolla::expr::Literal(kInputQtype)))
                      .status());

  {  // bit["0"]
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromInt_G_Gbit_N_20_2_P";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(auto qexpr_op, ::arolla::QExprOperatorFromFunction(
                                        LoadFromIntFunctor0 /*bit["0"]*/ ()));
    RETURN_IF_ERROR(::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
        kOperatorName, qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
        ::arolla::expr::RegisterOperator(
            kOperatorName,
            arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/
                arolla::expr::Literal(qexpr_op->signature()->output_type())))
            .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/"
        "testing:test_input_loader_operators_set";
    metadata.build_details.op_class =
        R"FUNCTOR_NAME(my_namespace::LoadFromIntFunctor0/*bit["0"]*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/"
        "test_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/"
        "testing:test_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // double
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromInt_G_Gdouble";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(auto qexpr_op, ::arolla::QExprOperatorFromFunction(
                                        LoadFromIntFunctor1 /*double*/ ()));
    RETURN_IF_ERROR(::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
        kOperatorName, qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
        ::arolla::expr::RegisterOperator(
            kOperatorName,
            arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/
                arolla::expr::Literal(qexpr_op->signature()->output_type())))
            .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/"
        "testing:test_input_loader_operators_set";
    metadata.build_details.op_class =
        R"FUNCTOR_NAME(my_namespace::LoadFromIntFunctor1/*double*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/"
        "test_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/"
        "testing:test_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // self
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromInt_G_Gself";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(auto qexpr_op, ::arolla::QExprOperatorFromFunction(
                                        LoadFromIntFunctor2 /*self*/ ()));
    RETURN_IF_ERROR(::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
        kOperatorName, qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
        ::arolla::expr::RegisterOperator(
            kOperatorName,
            arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/
                arolla::expr::Literal(qexpr_op->signature()->output_type())))
            .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/"
        "testing:test_input_loader_operators_set";
    metadata.build_details.op_class =
        R"FUNCTOR_NAME(my_namespace::LoadFromIntFunctor2/*self*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/"
        "test_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/"
        "testing:test_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  return absl::OkStatus();
}

AROLLA_INITIALIZER(.init_fn = RegisterIOOperators0);

}  // namespace
}  // namespace my_namespace
