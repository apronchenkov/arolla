// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_proto_slot_listener

#include <functional>
#include <optional>

#include "arolla/codegen/io/multi_loader.h"
#include "arolla/dense_array/dense_array.h"
#include "arolla/dense_array/qtype/types.h"
#include "arolla/proto/test.pb.h"
#include "arolla/proto/test_extension.pb.h"
#include "arolla/proto/test_proto3.pb.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/util/map.h"
#include "arolla/util/text.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/slot_listener.h"
#include "arolla/util/status.h"
#include "arolla/memory/frame.h"
#include "arolla/io/chain_slot_listener.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/qtype/typed_slot.h"
#include "absl/strings/string_view.h"
#include "arolla/util/meta.h"

namespace {
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundSlotListener;
using ::arolla::ChainSlotListener;
using ::arolla::ConstFramePtr;
using ::arolla::FrameLayout;
using ::arolla::GetQType;
using ::arolla::QTypePtr;
using ::arolla::SlotListener;
using ::arolla::TypedSlot;
}

namespace my_namespace_GetProtoSlotListenerImplNamespace {

using Output = ::testing_namespace::Root;

namespace {
namespace {
namespace accessors_listener {

template <class Fn>
using accessor_lambda_result_t = std::decay_t<::arolla::meta::head_t<
    typename ::arolla::meta::function_traits<Fn>::arg_types>>;



constexpr auto accessor_lambda_0 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).a())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/a:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
          value_0.set_a(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_0_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_0)>;
using accessor_lambda_0_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_0)>::return_type, absl::Status>;
using output_slot_0_t = FrameLayout::Slot<
    accessor_lambda_0_result_t>;

constexpr auto accessor_lambda_1 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).bytes_cord())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/bytes_cord:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
          value_0.set_bytes_cord(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_1_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_1)>;
using accessor_lambda_1_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_1)>::return_type, absl::Status>;
using output_slot_1_t = FrameLayout::Slot<
    accessor_lambda_1_result_t>;

constexpr auto accessor_lambda_2 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).bytes_string_view())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/bytes_string_view:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
          value_0.set_bytes_string_view(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_2_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_2)>;
using accessor_lambda_2_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_2)>::return_type, absl::Status>;
using output_slot_2_t = FrameLayout::Slot<
    accessor_lambda_2_result_t>;

constexpr auto accessor_lambda_3 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).inners2().size())>;
          using value_type = ::arolla::proto::arolla_size_t;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/inners2/@size:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
          ::arolla::codegen::io::ResizeRepeatedProtoField(value_0.mutable_inners2(), proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_3_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_3)>;
using accessor_lambda_3_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_3)>::return_type, absl::Status>;
using output_slot_3_t = FrameLayout::Slot<
    accessor_lambda_3_result_t>;

constexpr auto accessor_lambda_4 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).raw_bytes())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/raw_bytes:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
          value_0.set_raw_bytes(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_4_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_4)>;
using accessor_lambda_4_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_4)>::return_type, absl::Status>;
using output_slot_4_t = FrameLayout::Slot<
    accessor_lambda_4_result_t>;

constexpr auto accessor_lambda_5 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).str())>;
          using value_type = ::arolla::Text;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/str:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
          value_0.set_str(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_5_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_5)>;
using accessor_lambda_5_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_5)>::return_type, absl::Status>;
using output_slot_5_t = FrameLayout::Slot<
    accessor_lambda_5_result_t>;

constexpr auto accessor_lambda_6 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).str_cord())>;
          using value_type = ::arolla::Text;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/str_cord:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
          value_0.set_str_cord(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_6_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_6)>;
using accessor_lambda_6_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_6)>::return_type, absl::Status>;
using output_slot_6_t = FrameLayout::Slot<
    accessor_lambda_6_result_t>;

constexpr auto accessor_lambda_7 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).str_string_view())>;
          using value_type = ::arolla::Text;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/str_string_view:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
          value_0.set_str_string_view(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_7_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_7)>;
using accessor_lambda_7_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_7)>::return_type, absl::Status>;
using output_slot_7_t = FrameLayout::Slot<
    accessor_lambda_7_result_t>;

constexpr auto accessor_lambda_8 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inner().inners2(0).z())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(input, inner))) { return 0; }
  const auto& final_size_last = input.inner();
return final_size_last.inners2().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inner/inners2/z:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS((*output_ptr), inner))) { continue; }
  auto& value_0_last = *(*output_ptr).mutable_inner();
for (auto& value_0 : *value_0_last.mutable_inners2()) {
    if (input.present(id)) {
          value_0.set_z(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_8_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_8)>;
using accessor_lambda_8_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_8)>::return_type, absl::Status>;
using output_slot_8_t = FrameLayout::Slot<
    accessor_lambda_8_result_t>;

constexpr auto accessor_lambda_9 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).GetExtension(::testing_extension_namespace::InnerExtension::inner_ext).inner_extension_x_int32())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/Ext::testing_extension_namespace.InnerExtension.inner_ext/inner_extension_x_int32:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
  auto& final_item = *value_0.MutableExtension(::testing_extension_namespace::InnerExtension::inner_ext);
          final_item.set_inner_extension_x_int32(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_9_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_9)>;
using accessor_lambda_9_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_9)>::return_type, absl::Status>;
using output_slot_9_t = FrameLayout::Slot<
    accessor_lambda_9_result_t>;

constexpr auto accessor_lambda_10 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).inner2().z())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/inner2/z:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
  auto& final_item = *value_0.mutable_inner2();
          final_item.set_z(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_10_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_10)>;
using accessor_lambda_10_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_10)>::return_type, absl::Status>;
using output_slot_10_t = FrameLayout::Slot<
    accessor_lambda_10_result_t>;

constexpr auto accessor_lambda_11 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).inners2(0).z())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (const auto& value_0 : input.inners()) {
size_t final_size = [&]() {
return value_0.inners2().size(); }();
total_size += final_size;
}}
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/inners2/z:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
for (auto& value_1 : *value_0.mutable_inners2()) {
    if (input.present(id)) {
          value_1.set_z(proto_value_type(input.values[id]));
        }
        ++id;
  }}}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_11_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_11)>;
using accessor_lambda_11_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_11)>::return_type, absl::Status>;
using output_slot_11_t = FrameLayout::Slot<
    accessor_lambda_11_result_t>;

constexpr size_t kSkippedOffset = std::numeric_limits<size_t>::max();

struct SlotListenerLambdaCaller {
  size_t offsets[12];
  // true iff at least one slot in the group of size 8 is present
  bool offset_group_present[2] = {false, false};

  template <class Output>  // templated in order to trigger constexpr if
  Status operator()(ConstFramePtr frame, Output* output) const {
    if (offset_group_present[0]) {
      if (auto offset = offsets[0]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_0_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_0(
            frame.Get(
                output_slot_0_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_0(
            frame.Get(
                output_slot_0_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[1]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_1_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_1(
            frame.Get(
                output_slot_1_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_1(
            frame.Get(
                output_slot_1_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[2]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_2_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_2(
            frame.Get(
                output_slot_2_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_2(
            frame.Get(
                output_slot_2_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[3]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_3_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_3(
            frame.Get(
                output_slot_3_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_3(
            frame.Get(
                output_slot_3_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[4]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_4_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_4(
            frame.Get(
                output_slot_4_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_4(
            frame.Get(
                output_slot_4_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[5]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_5_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_5(
            frame.Get(
                output_slot_5_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_5(
            frame.Get(
                output_slot_5_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[6]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_6_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_6(
            frame.Get(
                output_slot_6_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_6(
            frame.Get(
                output_slot_6_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[7]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_7_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_7(
            frame.Get(
                output_slot_7_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_7(
            frame.Get(
                output_slot_7_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
    }
    if (offset_group_present[1]) {
      if (auto offset = offsets[8]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_8_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_8(
            frame.Get(
                output_slot_8_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_8(
            frame.Get(
                output_slot_8_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[9]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_9_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_9(
            frame.Get(
                output_slot_9_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_9(
            frame.Get(
                output_slot_9_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[10]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_10_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_10(
            frame.Get(
                output_slot_10_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_10(
            frame.Get(
                output_slot_10_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[11]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_11_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_11(
            frame.Get(
                output_slot_11_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_11(
            frame.Get(
                output_slot_11_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
    }
    return ::absl::OkStatus();
  }
};

class Listener final : public ::arolla::StaticSlotListener<Output> {
 public:
  Listener()
    :StaticSlotListener(
      // use special builder to reduce binary size and stack pressure
      []() {
        arolla::codegen::NamedQTypeVectorBuilder builder;
        builder.Add("/inners/a", GetQType<accessor_lambda_0_result_t>());
        builder.Add("/inners/bytes_cord", GetQType<accessor_lambda_1_result_t>());
        builder.Add("/inners/bytes_string_view", GetQType<accessor_lambda_2_result_t>());
        builder.Add("/inners/inners2/@size", GetQType<accessor_lambda_3_result_t>());
        builder.Add("/inners/raw_bytes", GetQType<accessor_lambda_4_result_t>());
        builder.Add("/inners/str", GetQType<accessor_lambda_5_result_t>());
        builder.Add("/inners/str_cord", GetQType<accessor_lambda_6_result_t>());
        builder.Add("/inners/str_string_view", GetQType<accessor_lambda_7_result_t>());
        builder.Add("/inner/inners2/z", GetQType<accessor_lambda_8_result_t>());
        builder.Add("/inners/Ext::testing_extension_namespace.InnerExtension.inner_ext/inner_extension_x_int32", GetQType<accessor_lambda_9_result_t>());
        builder.Add("/inners/inner2/z", GetQType<accessor_lambda_10_result_t>());
        builder.Add("/inners/inners2/z", GetQType<accessor_lambda_11_result_t>());
        return std::move(builder).Build();
      }()) {}

 private:
  StatusOr<BoundSlotListener<Output>> BindImpl(
      // The slots corresponding to this SlotListener's inputs.
      const absl::flat_hash_map<std::string, TypedSlot>& input_slots)
      const override {
    ASSIGN_OR_RETURN(
        std::vector<std::optional<TypedSlot>> input_slots_in_order,
        ::arolla::MaybeFindSlotsAndVerifyTypes(types_in_order(), input_slots));
    SlotListenerLambdaCaller fn;
    for (size_t i = 0; i != 12; ++i) {
      auto slot = input_slots_in_order[i];
      fn.offsets[i] = slot.has_value() ? slot->byte_offset() : kSkippedOffset;
      if (slot.has_value()) {
        fn.offset_group_present[i / 8] = true;
      }
    }
    return fn;
  }
};

}  // namespace accessors_listener

namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being processed.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/45,
        /*kNodeCount=*/58>;

// Provides access to the references inside the frame for each leaf.
class OutputGetter {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_outputs;
  ConstFramePtr frame;

 public:

  // protopath=`BrOkEn_CaSe` name=`/BrOkEn_CaSe`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get0(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().broken_case())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[0],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`Ext::testing_extension_namespace.extension_x_int32` name=`/Ext::testing_extension_namespace.extension_x_int32`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get1(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().GetExtension(::testing_extension_namespace::extension_x_int32))>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[1],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/Ext::testing_extension_namespace.InnerExtension.inner_ext/inner_extension_x_int32` name=`/inner/Ext::testing_extension_namespace.InnerExtension.inner_ext/inner_extension_x_int32`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get2(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().inner().GetExtension(::testing_extension_namespace::InnerExtension::inner_ext).inner_extension_x_int32())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[2],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/a` name=`/inner/a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get3(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().inner().a())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[3],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/bytes_cord` name=`/inner/bytes_cord`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get4(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().inner().bytes_cord())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[4],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/bytes_string_view` name=`/inner/bytes_string_view`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get5(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().inner().bytes_string_view())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[5],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/inner2/z` name=`/inner/inner2/z`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get6(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().inner().inner2().z())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[6],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/count(inners2[:])` name=`/inner/inners2/@size`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get7(size_t offset) const {
    using result_type = ::arolla::DenseArrayShape;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[7],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/raw_bytes` name=`/inner/raw_bytes`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get8(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().inner().raw_bytes())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[8],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/str` name=`/inner/str`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get9(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[9],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/str_cord` name=`/inner/str_cord`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get10(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[10],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/str_string_view` name=`/inner/str_string_view`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get11(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[11],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/a` name=`inner__a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get12(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().inner().a())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[12],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`count(inners[:])` name=`/inners/@size`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get13(size_t offset) const {
    using result_type = ::arolla::DenseArrayShape;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[13],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`private` name=`/private`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get14(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().private_())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[14],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`proto3/non_optional_i32` name=`/proto3/non_optional_i32`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get15(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().proto3().non_optional_i32())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[15],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`raw_bytes` name=`/raw_bytes`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get16(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().raw_bytes())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[16],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`str` name=`/str`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get17(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[17],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x` name=`/x`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get18(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[18],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x0` name=`/x0`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get19(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x0())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[19],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x1` name=`/x1`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get20(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x1())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[20],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x2` name=`/x2`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get21(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x2())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[21],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x3` name=`/x3`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get22(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x3())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[22],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x4` name=`/x4`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get23(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x4())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[23],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x5` name=`/x5`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get24(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x5())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[24],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x6` name=`/x6`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get25(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x6())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[25],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x7` name=`/x7`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get26(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x7())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[26],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x8` name=`/x8`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get27(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x8())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[27],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x9` name=`/x9`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get28(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x9())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[28],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_bytes_cord` name=`/x_bytes_cord`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get29(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x_bytes_cord())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[29],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_bytes_string_view` name=`/x_bytes_string_view`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get30(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x_bytes_string_view())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[30],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_double` name=`/x_double`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get31(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x_double())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[31],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_enum` name=`/x_enum`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get32(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x_enum())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[32],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_fixed64` name=`/x_fixed64`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get33(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x_fixed64())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[33],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_float` name=`/x_float`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get34(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x_float())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[34],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_int64` name=`/x_int64`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get35(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x_int64())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[35],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_string_cord` name=`/x_string_cord`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get36(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[36],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_string_string_view` name=`/x_string_string_view`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get37(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[37],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_uint32` name=`/x_uint32`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get38(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x_uint32())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[38],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x_uint64` name=`/x_uint64`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get39(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x_uint64())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[39],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[0]/a` name=`inners_0__a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get40(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().inners(0).a())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[40],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`map_int["a"]` name=`map_int_a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get41(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().map_int().at("a"))>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[41],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`raw_bytes` name=`raw_bytes`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get42(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().raw_bytes())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[42],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`str` name=`str`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get43(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[43],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`ys[0]` name=`ys_0`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get44(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().ys(0))>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[44],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

};


using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get3(0))>>;
using ResultType_4 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get4(0))>>;
using ResultType_5 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get5(0))>>;
using ResultType_6 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get6(0))>>;
using ResultType_7 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get7(0))>>;
using ResultType_8 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get8(0))>>;
using ResultType_9 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get9(0))>>;
using ResultType_10 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get10(0))>>;
using ResultType_11 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get11(0))>>;
using ResultType_12 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get12(0))>>;
using ResultType_13 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get13(0))>>;
using ResultType_14 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get14(0))>>;
using ResultType_15 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get15(0))>>;
using ResultType_16 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get16(0))>>;
using ResultType_17 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get17(0))>>;
using ResultType_18 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get18(0))>>;
using ResultType_19 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get19(0))>>;
using ResultType_20 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get20(0))>>;
using ResultType_21 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get21(0))>>;
using ResultType_22 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get22(0))>>;
using ResultType_23 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get23(0))>>;
using ResultType_24 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get24(0))>>;
using ResultType_25 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get25(0))>>;
using ResultType_26 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get26(0))>>;
using ResultType_27 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get27(0))>>;
using ResultType_28 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get28(0))>>;
using ResultType_29 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get29(0))>>;
using ResultType_30 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get30(0))>>;
using ResultType_31 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get31(0))>>;
using ResultType_32 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get32(0))>>;
using ResultType_33 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get33(0))>>;
using ResultType_34 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get34(0))>>;
using ResultType_35 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get35(0))>>;
using ResultType_36 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get36(0))>>;
using ResultType_37 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get37(0))>>;
using ResultType_38 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get38(0))>>;
using ResultType_39 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get39(0))>>;
using ResultType_40 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get40(0))>>;
using ResultType_41 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get41(0))>>;
using ResultType_42 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get42(0))>>;
using ResultType_43 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get43(0))>>;
using ResultType_44 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get44(0))>>;

// Traverse the proto and put results for all single values from the frame.
class SlotReader {
 public:

 void CollectResults(Output& output, const OutputGetter& inputs) {
   Output& tmp_12 = output;

    // protopath=`ROOT` fictive
    [&]() {
      if (!inputs.requested_outputs->common.node_requested[6]) {
        return;
      }
      auto& tmp_6 = tmp_12;
      // protopath=`BrOkEn_CaSe` name=`/BrOkEn_CaSe`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[0];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get0(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().broken_case())>;
          if (input.present) {
            tmp_6.set_broken_case(proto_type(input.value));
          }
        }
      }();
      // protopath=`Ext::testing_extension_namespace.extension_x_int32` name=`/Ext::testing_extension_namespace.extension_x_int32`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[1];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get1(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().GetExtension(::testing_extension_namespace::extension_x_int32))>;
          if (input.present) {
            tmp_6.SetExtension(::testing_extension_namespace::extension_x_int32, proto_type(input.value));
          }
        }
      }();
      // protopath=`inner`
      [&]() {
        if (!inputs.requested_outputs->common.node_requested[4]) {
          return;
        }
        auto& tmp_4 = *tmp_6.mutable_inner();
        // protopath=`inner` fictive
        [&]() {
          if (!inputs.requested_outputs->common.node_requested[2]) {
            return;
          }
          auto& tmp_2 = tmp_4;
          // protopath=`inner/Ext::testing_extension_namespace.InnerExtension.inner_ext`
          [&]() {
            if (!inputs.requested_outputs->common.node_requested[0]) {
              return;
            }
            auto& tmp_0 = *tmp_2.MutableExtension(::testing_extension_namespace::InnerExtension::inner_ext);
            // protopath=`inner/Ext::testing_extension_namespace.InnerExtension.inner_ext/inner_extension_x_int32` name=`/inner/Ext::testing_extension_namespace.InnerExtension.inner_ext/inner_extension_x_int32`
            if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[2];
                offset != kSkippedOffset) {
              const auto& input = inputs.Get2(offset);
              using proto_type = std::decay_t<decltype(
                      std::declval<Output&>().inner().GetExtension(::testing_extension_namespace::InnerExtension::inner_ext).inner_extension_x_int32())>;
              if (input.present) {
                tmp_0.set_inner_extension_x_int32(proto_type(input.value));
              }
            }
          }();
          // protopath=`inner/a` name=`/inner/a`
          [&]() {
            if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[3];
                offset != kSkippedOffset) {
              const auto& input = inputs.Get3(offset);
              using proto_type = std::decay_t<decltype(
                      std::declval<Output&>().inner().a())>;
              if (input.present) {
                tmp_2.set_a(proto_type(input.value));
              }
            }
          }();
          // protopath=`inner/bytes_cord` name=`/inner/bytes_cord`
          [&]() {
            if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[4];
                offset != kSkippedOffset) {
              const auto& input = inputs.Get4(offset);
              using proto_type = std::decay_t<decltype(
                      std::declval<Output&>().inner().bytes_cord())>;
              if (input.present) {
                tmp_2.set_bytes_cord(proto_type(input.value));
              }
            }
          }();
          // protopath=`inner/bytes_string_view` name=`/inner/bytes_string_view`
          [&]() {
            if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[5];
                offset != kSkippedOffset) {
              const auto& input = inputs.Get5(offset);
              using proto_type = std::decay_t<decltype(
                      std::declval<Output&>().inner().bytes_string_view())>;
              if (input.present) {
                tmp_2.set_bytes_string_view(proto_type(input.value));
              }
            }
          }();
          // protopath=`inner/inner2`
          [&]() {
            if (!inputs.requested_outputs->common.node_requested[1]) {
              return;
            }
            auto& tmp_1 = *tmp_2.mutable_inner2();
            // protopath=`inner/inner2/z` name=`/inner/inner2/z`
            if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[6];
                offset != kSkippedOffset) {
              const auto& input = inputs.Get6(offset);
              using proto_type = std::decay_t<decltype(
                      std::declval<Output&>().inner().inner2().z())>;
              if (input.present) {
                tmp_1.set_z(proto_type(input.value));
              }
            }
          }();
          // protopath=`inner/count(inners2[:])` name=`/inner/inners2/@size`
          [&]() {
            if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[7];
                offset != kSkippedOffset) {
              const auto& input = inputs.Get7(offset);
              ::arolla::codegen::io::ResizeRepeatedProtoField(tmp_2.mutable_inners2(), input.size);
            }
          }();
          // protopath=`inner/raw_bytes` name=`/inner/raw_bytes`
          [&]() {
            if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[8];
                offset != kSkippedOffset) {
              const auto& input = inputs.Get8(offset);
              using proto_type = std::decay_t<decltype(
                      std::declval<Output&>().inner().raw_bytes())>;
              if (input.present) {
                tmp_2.set_raw_bytes(proto_type(input.value));
              }
            }
          }();
          // protopath=`inner/str` name=`/inner/str`
          [&]() {
            if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[9];
                offset != kSkippedOffset) {
              const auto& input = inputs.Get9(offset);
              using proto_type = std::decay_t<decltype(
                      std::declval<Output&>().inner().str())>;
              if (input.present) {
                tmp_2.set_str(proto_type(input.value));
              }
            }
          }();
        }();
        // protopath=`inner` fictive
        [&]() {
          if (!inputs.requested_outputs->common.node_requested[3]) {
            return;
          }
          auto& tmp_3 = tmp_4;
          // protopath=`inner/str_cord` name=`/inner/str_cord`
          [&]() {
            if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[10];
                offset != kSkippedOffset) {
              const auto& input = inputs.Get10(offset);
              using proto_type = std::decay_t<decltype(
                      std::declval<Output&>().inner().str_cord())>;
              if (input.present) {
                tmp_3.set_str_cord(proto_type(input.value));
              }
            }
          }();
          // protopath=`inner/str_string_view` name=`/inner/str_string_view`
          [&]() {
            if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[11];
                offset != kSkippedOffset) {
              const auto& input = inputs.Get11(offset);
              using proto_type = std::decay_t<decltype(
                      std::declval<Output&>().inner().str_string_view())>;
              if (input.present) {
                tmp_3.set_str_string_view(proto_type(input.value));
              }
            }
          }();
          // protopath=`inner/a` name=`inner__a`
          [&]() {
            if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[12];
                offset != kSkippedOffset) {
              const auto& input = inputs.Get12(offset);
              using proto_type = std::decay_t<decltype(
                      std::declval<Output&>().inner().a())>;
              if (input.present) {
                tmp_3.set_a(proto_type(input.value));
              }
            }
          }();
        }();
      }();
      // protopath=`count(inners[:])` name=`/inners/@size`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[13];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get13(offset);
          ::arolla::codegen::io::ResizeRepeatedProtoField(tmp_6.mutable_inners(), input.size);
        }
      }();
      // protopath=`private` name=`/private`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[14];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get14(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().private_())>;
          if (input.present) {
            tmp_6.set_private_(proto_type(input.value));
          }
        }
      }();
      // protopath=`proto3`
      [&]() {
        if (!inputs.requested_outputs->common.node_requested[5]) {
          return;
        }
        auto& tmp_5 = *tmp_6.mutable_proto3();
        // protopath=`proto3/non_optional_i32` name=`/proto3/non_optional_i32`
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[15];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get15(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().proto3().non_optional_i32())>;
          if (input.present) {
            tmp_5.set_non_optional_i32(proto_type(input.value));
          }
        }
      }();
      // protopath=`raw_bytes` name=`/raw_bytes`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[16];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get16(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().raw_bytes())>;
          if (input.present) {
            tmp_6.set_raw_bytes(proto_type(input.value));
          }
        }
      }();
      // protopath=`str` name=`/str`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[17];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get17(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().str())>;
          if (input.present) {
            tmp_6.set_str(proto_type(input.value));
          }
        }
      }();
    }();
    // protopath=`ROOT` fictive
    [&]() {
      if (!inputs.requested_outputs->common.node_requested[7]) {
        return;
      }
      auto& tmp_7 = tmp_12;
      // protopath=`x` name=`/x`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[18];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get18(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x())>;
          if (input.present) {
            tmp_7.set_x(proto_type(input.value));
          }
        }
      }();
      // protopath=`x0` name=`/x0`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[19];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get19(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x0())>;
          if (input.present) {
            tmp_7.set_x0(proto_type(input.value));
          }
        }
      }();
      // protopath=`x1` name=`/x1`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[20];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get20(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x1())>;
          if (input.present) {
            tmp_7.set_x1(proto_type(input.value));
          }
        }
      }();
      // protopath=`x2` name=`/x2`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[21];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get21(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x2())>;
          if (input.present) {
            tmp_7.set_x2(proto_type(input.value));
          }
        }
      }();
      // protopath=`x3` name=`/x3`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[22];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get22(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x3())>;
          if (input.present) {
            tmp_7.set_x3(proto_type(input.value));
          }
        }
      }();
      // protopath=`x4` name=`/x4`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[23];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get23(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x4())>;
          if (input.present) {
            tmp_7.set_x4(proto_type(input.value));
          }
        }
      }();
      // protopath=`x5` name=`/x5`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[24];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get24(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x5())>;
          if (input.present) {
            tmp_7.set_x5(proto_type(input.value));
          }
        }
      }();
      // protopath=`x6` name=`/x6`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[25];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get25(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x6())>;
          if (input.present) {
            tmp_7.set_x6(proto_type(input.value));
          }
        }
      }();
    }();
    // protopath=`ROOT` fictive
    [&]() {
      if (!inputs.requested_outputs->common.node_requested[8]) {
        return;
      }
      auto& tmp_8 = tmp_12;
      // protopath=`x7` name=`/x7`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[26];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get26(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x7())>;
          if (input.present) {
            tmp_8.set_x7(proto_type(input.value));
          }
        }
      }();
      // protopath=`x8` name=`/x8`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[27];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get27(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x8())>;
          if (input.present) {
            tmp_8.set_x8(proto_type(input.value));
          }
        }
      }();
      // protopath=`x9` name=`/x9`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[28];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get28(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x9())>;
          if (input.present) {
            tmp_8.set_x9(proto_type(input.value));
          }
        }
      }();
      // protopath=`x_bytes_cord` name=`/x_bytes_cord`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[29];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get29(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x_bytes_cord())>;
          if (input.present) {
            tmp_8.set_x_bytes_cord(proto_type(input.value));
          }
        }
      }();
      // protopath=`x_bytes_string_view` name=`/x_bytes_string_view`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[30];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get30(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x_bytes_string_view())>;
          if (input.present) {
            tmp_8.set_x_bytes_string_view(proto_type(input.value));
          }
        }
      }();
      // protopath=`x_double` name=`/x_double`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[31];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get31(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x_double())>;
          if (input.present) {
            tmp_8.set_x_double(proto_type(input.value));
          }
        }
      }();
      // protopath=`x_enum` name=`/x_enum`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[32];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get32(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x_enum())>;
          if (input.present) {
            tmp_8.set_x_enum(proto_type(input.value));
          }
        }
      }();
      // protopath=`x_fixed64` name=`/x_fixed64`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[33];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get33(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x_fixed64())>;
          if (input.present) {
            tmp_8.set_x_fixed64(proto_type(input.value));
          }
        }
      }();
    }();
    // protopath=`ROOT` fictive
    [&]() {
      if (!inputs.requested_outputs->common.node_requested[10]) {
        return;
      }
      auto& tmp_10 = tmp_12;
      // protopath=`x_float` name=`/x_float`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[34];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get34(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x_float())>;
          if (input.present) {
            tmp_10.set_x_float(proto_type(input.value));
          }
        }
      }();
      // protopath=`x_int64` name=`/x_int64`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[35];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get35(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x_int64())>;
          if (input.present) {
            tmp_10.set_x_int64(proto_type(input.value));
          }
        }
      }();
      // protopath=`x_string_cord` name=`/x_string_cord`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[36];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get36(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x_string_cord())>;
          if (input.present) {
            tmp_10.set_x_string_cord(proto_type(input.value));
          }
        }
      }();
      // protopath=`x_string_string_view` name=`/x_string_string_view`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[37];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get37(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x_string_string_view())>;
          if (input.present) {
            tmp_10.set_x_string_string_view(proto_type(input.value));
          }
        }
      }();
      // protopath=`x_uint32` name=`/x_uint32`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[38];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get38(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x_uint32())>;
          if (input.present) {
            tmp_10.set_x_uint32(proto_type(input.value));
          }
        }
      }();
      // protopath=`x_uint64` name=`/x_uint64`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[39];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get39(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().x_uint64())>;
          if (input.present) {
            tmp_10.set_x_uint64(proto_type(input.value));
          }
        }
      }();
      // protopath=`inners[0]`
      [&]() {
        if (!inputs.requested_outputs->common.node_requested[9]) {
          return;
        }
        if (!(tmp_10.inners().size() > 0)) {
          return;
        }
        auto& tmp_9 = tmp_10.mutable_inners()->at(0);
        // protopath=`inners[0]/a` name=`inners_0__a`
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[40];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get40(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().inners(0).a())>;
          if (input.present) {
            tmp_9.set_a(proto_type(input.value));
          }
        }
      }();
      // protopath=`map_int["a"]` name=`map_int_a`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[41];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get41(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().map_int().at("a"))>;
          if (input.present) {
            (*tmp_10.mutable_map_int())["a"] = proto_type(input.value);
          }
        }
      }();
    }();
    // protopath=`ROOT` fictive
    [&]() {
      if (!inputs.requested_outputs->common.node_requested[11]) {
        return;
      }
      auto& tmp_11 = tmp_12;
      // protopath=`raw_bytes` name=`raw_bytes`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[42];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get42(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().raw_bytes())>;
          if (input.present) {
            tmp_11.set_raw_bytes(proto_type(input.value));
          }
        }
      }();
      // protopath=`str` name=`str`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[43];
            offset != kSkippedOffset) {
          const auto& input = inputs.Get43(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().str())>;
          if (input.present) {
            tmp_11.set_str(proto_type(input.value));
          }
        }
      }();
      // protopath=`ys[0]` name=`ys_0`
      [&]() {
        if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[44];
            offset != kSkippedOffset) {
          if (!(tmp_11.ys().size() > 0)) {
            return;
          }
          const auto& input = inputs.Get44(offset);
          using proto_type = std::decay_t<decltype(
                  std::declval<Output&>().ys(0))>;
          if (input.present) {
            tmp_11.set_ys(0, proto_type(input.value));
          }
        }
      }();
    }();
  }
};

// SlotListener for all single value protopathes.
class Listener final : public ::arolla::StaticSlotListener<Output> {
 public:
  Listener()
    :StaticSlotListener(
      // use special builder to reduce binary size and stack pressure
      []() {
        ::arolla::codegen::NamedQTypeVectorBuilder builder;
        builder.Add("/BrOkEn_CaSe", GetQType<ResultType_0>());
        builder.Add("/Ext::testing_extension_namespace.extension_x_int32", GetQType<ResultType_1>());
        builder.Add("/inner/Ext::testing_extension_namespace.InnerExtension.inner_ext/inner_extension_x_int32", GetQType<ResultType_2>());
        builder.Add("/inner/a", GetQType<ResultType_3>());
        builder.Add("/inner/bytes_cord", GetQType<ResultType_4>());
        builder.Add("/inner/bytes_string_view", GetQType<ResultType_5>());
        builder.Add("/inner/inner2/z", GetQType<ResultType_6>());
        builder.Add("/inner/inners2/@size", GetQType<ResultType_7>());
        builder.Add("/inner/raw_bytes", GetQType<ResultType_8>());
        builder.Add("/inner/str", GetQType<ResultType_9>());
        builder.Add("/inner/str_cord", GetQType<ResultType_10>());
        builder.Add("/inner/str_string_view", GetQType<ResultType_11>());
        builder.Add("inner__a", GetQType<ResultType_12>());
        builder.Add("/inners/@size", GetQType<ResultType_13>());
        builder.Add("/private", GetQType<ResultType_14>());
        builder.Add("/proto3/non_optional_i32", GetQType<ResultType_15>());
        builder.Add("/raw_bytes", GetQType<ResultType_16>());
        builder.Add("/str", GetQType<ResultType_17>());
        builder.Add("/x", GetQType<ResultType_18>());
        builder.Add("/x0", GetQType<ResultType_19>());
        builder.Add("/x1", GetQType<ResultType_20>());
        builder.Add("/x2", GetQType<ResultType_21>());
        builder.Add("/x3", GetQType<ResultType_22>());
        builder.Add("/x4", GetQType<ResultType_23>());
        builder.Add("/x5", GetQType<ResultType_24>());
        builder.Add("/x6", GetQType<ResultType_25>());
        builder.Add("/x7", GetQType<ResultType_26>());
        builder.Add("/x8", GetQType<ResultType_27>());
        builder.Add("/x9", GetQType<ResultType_28>());
        builder.Add("/x_bytes_cord", GetQType<ResultType_29>());
        builder.Add("/x_bytes_string_view", GetQType<ResultType_30>());
        builder.Add("/x_double", GetQType<ResultType_31>());
        builder.Add("/x_enum", GetQType<ResultType_32>());
        builder.Add("/x_fixed64", GetQType<ResultType_33>());
        builder.Add("/x_float", GetQType<ResultType_34>());
        builder.Add("/x_int64", GetQType<ResultType_35>());
        builder.Add("/x_string_cord", GetQType<ResultType_36>());
        builder.Add("/x_string_string_view", GetQType<ResultType_37>());
        builder.Add("/x_uint32", GetQType<ResultType_38>());
        builder.Add("/x_uint64", GetQType<ResultType_39>());
        builder.Add("inners_0__a", GetQType<ResultType_40>());
        builder.Add("map_int_a", GetQType<ResultType_41>());
        builder.Add("raw_bytes", GetQType<ResultType_42>());
        builder.Add("str", GetQType<ResultType_43>());
        builder.Add("ys_0", GetQType<ResultType_44>());
        return std::move(builder).Build();
      }()) {}

 private:
  StatusOr<BoundSlotListener<Output>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& input_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         types_in_order(), input_slots));
    // Allocate on heap to reduce stack pressure.
    auto outputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(58);
      tree[3] = {2};
      tree[8] = {7};
      tree[12] = {3,4,5,6,8,9,10,11};
      tree[16] = {13,14,15};
      tree[17] = {12,16};
      tree[21] = {20};
      tree[24] = {0,1,17,18,19,21,22,23};
      tree[33] = {25,26,27,28,29,30,31,32};
      tree[42] = {34,35,36,37,38,39,40,41};
      tree[50] = {49};
      tree[52] = {43,44,45,46,47,48,50,51};
      tree[56] = {53,54,55};
      tree[57] = {24,33,42,52,56};
      return tree;
    }();
    CreateHierarchicalSingleValueRequestedInputs(
      optional_slots,
      /*size_leaves=*/{ 7, 13 },
      tree,
      outputs.get());
    return [outputs=std::move(*outputs)](
        ConstFramePtr frame, Output* output) {
      OutputGetter output_getter{&outputs, frame};
      SlotReader slot_reader;
      slot_reader.CollectResults(*output, output_getter);
      return absl::OkStatus();
    };
  }
};

}  // namespace single_value_protopath

}  // namespace

const SlotListener<Output>*
GetCollectionSlotListener() {
  static const SlotListener<Output>* impl = ChainSlotListener<Output>::Build(
      std::make_unique<single_value_protopath::Listener>(),
      std::make_unique<accessors_listener::Listener>()
      )->release();
  return impl;
}
}  // namespace
}  // namespace my_namespace_GetProtoSlotListenerImplNamespace

namespace my_namespace {

std::unique_ptr<::arolla::SlotListener<::testing_namespace::Root>>
GetProtoSlotListener() {
  return MakeNotOwningSlotListener(::my_namespace_GetProtoSlotListenerImplNamespace::GetCollectionSlotListener());
}

}  // namespace my_namespace

