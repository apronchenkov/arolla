// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_generator_based_input_loader

#include <memory>


#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace my_namespace_GetAccessorsGeneratedArrayLoaderImplNamespace {

using Input = ::std::array<int, 10>;

namespace {
namespace {
// Special value to mark not requested slot.
constexpr size_t kSkippedOffset = std::numeric_limits<size_t>::max();

constexpr auto accessor_lambda_0 = [](const auto& input) { return input[2]; };
using AccessorResultType_0 = ::arolla::InputLoaderAccessorResultType<
    decltype(accessor_lambda_0), Input>;

constexpr auto accessor_lambda_1 = [](const auto& input) { return input[3]; };
using AccessorResultType_1 = ::arolla::InputLoaderAccessorResultType<
    decltype(accessor_lambda_1), Input>;

constexpr auto accessor_lambda_2 = [](const auto& input) { return input[4]; };
using AccessorResultType_2 = ::arolla::InputLoaderAccessorResultType<
    decltype(accessor_lambda_2), Input>;

constexpr auto accessor_lambda_3 = [](const auto& input) { return input[5]; };
using AccessorResultType_3 = ::arolla::InputLoaderAccessorResultType<
    decltype(accessor_lambda_3), Input>;

constexpr auto accessor_lambda_4 = [](const auto& input) { return input[6]; };
using AccessorResultType_4 = ::arolla::InputLoaderAccessorResultType<
    decltype(accessor_lambda_4), Input>;

constexpr auto accessor_lambda_5 = [](const auto& input) { return input[1]; };
using AccessorResultType_5 = ::arolla::InputLoaderAccessorResultType<
    decltype(accessor_lambda_5), Input>;

constexpr auto accessor_lambda_6 = [](const auto& input) { return input[0]; };
using AccessorResultType_6 = ::arolla::InputLoaderAccessorResultType<
    decltype(accessor_lambda_6), Input>;


// Calling all accessors and put results to the frame.
struct AccessorsSlotSetter {
  // kSkippedOffset means a skipped slot
  size_t offsets[7];
  // true iff at least one slot in the group of size 8 is present
  bool offset_group_present[1] = {false};

  Status operator()(
      const Input& input, FramePtr frame, RawBufferFactory* factory) const {
    if (offset_group_present[0]) {
      if (size_t offset = offsets[0]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_0, input, factory,
            frame.GetMutable(::arolla::FrameLayout::Slot<
                AccessorResultType_0>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[1]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_1, input, factory,
            frame.GetMutable(::arolla::FrameLayout::Slot<
                AccessorResultType_1>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[2]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_2, input, factory,
            frame.GetMutable(::arolla::FrameLayout::Slot<
                AccessorResultType_2>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[3]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_3, input, factory,
            frame.GetMutable(::arolla::FrameLayout::Slot<
                AccessorResultType_3>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[4]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_4, input, factory,
            frame.GetMutable(::arolla::FrameLayout::Slot<
                AccessorResultType_4>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[5]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_5, input, factory,
            frame.GetMutable(::arolla::FrameLayout::Slot<
                AccessorResultType_5>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[6]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_6, input, factory,
            frame.GetMutable(::arolla::FrameLayout::Slot<
                AccessorResultType_6>::UnsafeSlotFromOffset(offset)));
      }
    }
    return OkStatus();
  }
};

// InputLoader based on accessors.
class AccessorsLoader final : public ::arolla::StaticInputLoader<Input> {
 public:
  AccessorsLoader()
    : ::arolla::StaticInputLoader<Input>(
          // avoid using initializer_list to reduce stack pressure
          []() {
            std::vector<std::pair<std::string, QTypePtr>> result(7);
            // Note: `result[i] =` is more binary size efficient as `emplace_back`.
            result[0] = {
                R"RL_CODEGEN_DELIM(a_2)RL_CODEGEN_DELIM",
                ::arolla::GetQType<AccessorResultType_0>()
            };
            result[1] = {
                R"RL_CODEGEN_DELIM(a_3)RL_CODEGEN_DELIM",
                ::arolla::GetQType<AccessorResultType_1>()
            };
            result[2] = {
                R"RL_CODEGEN_DELIM(a_4)RL_CODEGEN_DELIM",
                ::arolla::GetQType<AccessorResultType_2>()
            };
            result[3] = {
                R"RL_CODEGEN_DELIM(f_5)RL_CODEGEN_DELIM",
                ::arolla::GetQType<AccessorResultType_3>()
            };
            result[4] = {
                R"RL_CODEGEN_DELIM(f_6)RL_CODEGEN_DELIM",
                ::arolla::GetQType<AccessorResultType_4>()
            };
            result[5] = {
                R"RL_CODEGEN_DELIM(one)RL_CODEGEN_DELIM",
                ::arolla::GetQType<AccessorResultType_5>()
            };
            result[6] = {
                R"RL_CODEGEN_DELIM(zero)RL_CODEGEN_DELIM",
                ::arolla::GetQType<AccessorResultType_6>()
            };
            return result;
          }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         this->types_in_order(), output_slots));
    AccessorsSlotSetter fn;
    for (size_t i = 0; i != 7; ++i) {
      auto slot = optional_slots[i];
      fn.offsets[i] =
          slot.has_value() ? slot->byte_offset() : kSkippedOffset;
      if (slot.has_value()) {
        fn.offset_group_present[i / 8] = true;
      }
    }
    return BoundInputLoader<Input>(fn);
  }
};
}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>*
GetCollectionInputLoader() {
  static const InputLoader<Input>* impl = ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(static_cast<InputLoader<Input>*>(
            new AccessorsLoader()))
      )->release();
  return impl;
}
}  // namespace


namespace {

constexpr auto GetAllShardsInputLoader =
    ::my_namespace_GetAccessorsGeneratedArrayLoaderImplNamespace::GetCollectionInputLoader;

}  // namespace
}  // namespace my_namespace_GetAccessorsGeneratedArrayLoaderImplNamespace

namespace my_namespace {

std::unique_ptr<InputLoader<::std::array<int, 10>>>
GetAccessorsGeneratedArrayLoader() {
  return MakeNotOwningInputLoader(
      ::my_namespace_GetAccessorsGeneratedArrayLoaderImplNamespace::GetAllShardsInputLoader());
}

}  // namespace my_namespace

