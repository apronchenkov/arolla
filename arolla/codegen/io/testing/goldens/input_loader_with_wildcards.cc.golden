// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:input_loader_with_wildcards

#include <memory>


#include "arolla/codegen/io/multi_loader.h"
#include "arolla/dense_array/dense_array.h"
#include "arolla/dense_array/qtype/types.h"
#include "arolla/proto/testing/test.pb.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/util/map.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace my_namespace_GetWildcardMapProtoLoaderImplNamespace {

using Input = ::testing_namespace::Root;

namespace {
namespace {

namespace multi_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;

// In this namespace protopath inputs with `DenseArray` are being loaded.

using HierarchicalMultiValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalMultiValueRequestedInputsData<
        /*kLeafCount=*/1,
        /*kNodeCount=*/2>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalMultiValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:

  // protopath=`ys[:]` name=`/ys`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().ys(0))>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[0],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

};


using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;

// Traverse the proto and put results for all DenaseArray values to the frame.
class SlotSetter {
 public:
  // Returns total size of the array for
  // protopath=`ys[:]` name=`/ys`
  size_t TotalSize0() const {
    const auto* start_ptr = single_.intermediate0;
    return start_ptr == nullptr ? 0 :
           (*start_ptr).ys().size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`ys[:]` name=`/ys`
  void CollectResultFromIntermediate0(
      ResultType_0* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize0();
    using ValueT = ResultType_0::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`ROOT`
    // Loop is always one or zero iterations, we use a loop to use "continue".
    for (const auto* intermediate_ptr = single_.intermediate0;
         intermediate_ptr != nullptr;
         intermediate_ptr = nullptr) {
      const auto& tmp_1 = *intermediate_ptr;

      for (const auto& tmp_0 : tmp_1.ys()) {
        inserter.Add(tmp_0);
      }
    }

    *output = ResultType_0{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }



 void CollectResults(
     const Input& input, const OutputProvider& outputs,
     RawBufferFactory* buffer_factory) {
   single_.intermediate0 = &input;

    // protopath=`ys[:]` name=`/ys`
    if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[0];
        offset != kSkippedOffset) {
      CollectResultFromIntermediate0(
          outputs.GetMutable0(offset), buffer_factory);
    }
 }

 private:
  // Intermediate non vector data: pointers to messages and sizes.
  struct SingleValueData {
    const Input* intermediate0 = nullptr;
  };

  // Intermediate vector data: collection of pointers to messages.
  struct MultiValueData {
  };

  SingleValueData single_;
  MultiValueData multi_;
};

// InputLoader for all DenseArray value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
    : StaticInputLoader<Input>(
        // Use special builder to reduce binary size and stack pressure.
        []() {
          ::arolla::codegen::NamedQTypeVectorBuilder builder;
          builder.AddFromCommonPrefixWithPrevious(
              // /ys
              3,
              R"RL_CODEGEN_DELIM(/ys)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_0>());
          return std::move(builder).Build();
        }()) {}

 private:
  auto CreateProtopathTree() const {
    return []() {
      std::vector<std::vector<size_t>> tree(2);
      tree[1] = {0};
      return tree;
    }();
  }

  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalMultiValueRequestedInputs>();
    auto tree = CreateProtopathTree();
    CreateHierarchicalMultiValueRequestedInputs(
      optional_slots,
      tree,
      inputs.get());
    return BoundInputLoader<Input>([inputs=std::move(inputs)](
        const Input& input, FramePtr frame, RawBufferFactory* buffer_factory) {
      OutputProvider output_getter{inputs.get(), frame};
      SlotSetter slot_setter;
      slot_setter.CollectResults(input, output_getter, buffer_factory);
      return OkStatus();
    });
  }
};

}  // namespace multi_value_protopath
}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>*
GetCollectionInputLoader() {
  static const InputLoader<Input>* impl = ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(static_cast<InputLoader<Input>*>(
            new multi_value_protopath::Loader()))
      )->release();
  return impl;
}
}  // namespace


namespace {

// WildcardInputLoader /map_int["%s"]
constexpr auto wildcard_lambda_0 = [](const ::testing_namespace::Root& input, absl::string_view feature_key,
::arolla::proto::arolla_optional_value_t<decltype(input.map_int().at(feature_key))>* output) {
output->present = false;
  if (!(input.map_int().count(feature_key) > 0)) { return; }
  const auto& final_result = input.map_int().at(feature_key);
        output->present = true;
        output->value = final_result;
     };
using AccessorResultType_0 =
    ::arolla::WildcardAccessorResultType<
        decltype(wildcard_lambda_0), Input, std::string>;

absl::StatusOr<std::unique_ptr<InputLoader<Input>>>
CreateWildcardLoader0() {
  return WildcardInputLoader<Input>::Build(
      wildcard_lambda_0,
      absl::ParsedFormat<'s'>(R"accessor____name(/map_int["%s"])accessor____name"));
}

// WildcardInputLoader /map_string_inner["%s"]/a
constexpr auto wildcard_lambda_1 = [](const ::testing_namespace::Root& input, absl::string_view feature_key,
::arolla::proto::arolla_optional_value_t<decltype(input.map_string_inner().at(feature_key).a())>* output) {
output->present = false;
  if (!(input.map_string_inner().count(feature_key) > 0)) { return; }
  const auto& val_0 = input.map_string_inner().at(feature_key);
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_0, a))) { return; }
  const auto& final_result = val_0.a();
        output->present = true;
        output->value = final_result;
     };
using AccessorResultType_1 =
    ::arolla::WildcardAccessorResultType<
        decltype(wildcard_lambda_1), Input, std::string>;

absl::StatusOr<std::unique_ptr<InputLoader<Input>>>
CreateWildcardLoader1() {
  return WildcardInputLoader<Input>::Build(
      wildcard_lambda_1,
      absl::ParsedFormat<'s'>(R"accessor____name(/map_string_inner["%s"]/a)accessor____name"));
}

// WildcardInputLoader /map_string_inner["%s"]/as
constexpr auto wildcard_lambda_2 = [](const ::testing_namespace::Root& input, absl::string_view feature_key, ::arolla::RawBufferFactory* factory) {
using proto_value_type = std::decay_t<decltype(input.map_string_inner().at(feature_key).as(0))>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
          size_t total_size = [&](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
  if (!(input.map_string_inner().count(feature_key) > 0)) { return 0; }
  const auto& final_size_last = input.map_string_inner().at(feature_key);
return final_size_last.as().size(); }();
total_size += final_size;
return total_size;
  }(input);
using result_type = ::arolla::DenseArray<value_type>;
typename ::arolla::Buffer<value_type>::Builder bldr(
    total_size, factory);
auto inserter = bldr.GetInserter();
int64_t id = 0;
::arolla::bitmap::AlmostFullBuilder bitmap_bldr(
    total_size, factory);
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
  if (!(input.map_string_inner().count(feature_key) > 0)) { continue; }
  const auto& value_0_last = input.map_string_inner().at(feature_key);
for (const auto& value_0 : value_0_last.as()) {
id++;
inserter.Add(value_0);
  }}
return result_type{std::move(bldr).Build(),
                       std::move(bitmap_bldr).Build()};
 };
using AccessorResultType_2 =
    ::arolla::WildcardAccessorResultType<
        decltype(wildcard_lambda_2), Input, std::string>;

absl::StatusOr<std::unique_ptr<InputLoader<Input>>>
CreateWildcardLoader2() {
  return WildcardInputLoader<Input>::Build(
      wildcard_lambda_2,
      absl::ParsedFormat<'s'>(R"accessor____name(/map_string_inner["%s"]/as)accessor____name"));
}

constexpr auto GetAllShardsInputLoader =
    ::my_namespace_GetWildcardMapProtoLoaderImplNamespace::GetCollectionInputLoader;

// Returns InputLoader with additional wildcards support.
const InputLoader<Input>*
GetInputLoaderWithWildcards() {
  static const InputLoader<::testing_namespace::Root>* impl =
      []() -> absl::StatusOr<std::unique_ptr<InputLoader<::testing_namespace::Root>>> {
        auto loader = MakeNotOwningInputLoader(
            ::my_namespace_GetWildcardMapProtoLoaderImplNamespace::GetAllShardsInputLoader());
        std::vector<std::unique_ptr<InputLoader<::testing_namespace::Root>>> loaders;
        loaders.reserve(4);
        loaders.emplace_back(std::move(loader));
        ASSIGN_OR_RETURN(loaders.emplace_back(),
            ::my_namespace_GetWildcardMapProtoLoaderImplNamespace::CreateWildcardLoader0());
        ASSIGN_OR_RETURN(loaders.emplace_back(),
            ::my_namespace_GetWildcardMapProtoLoaderImplNamespace::CreateWildcardLoader1());
        ASSIGN_OR_RETURN(loaders.emplace_back(),
            ::my_namespace_GetWildcardMapProtoLoaderImplNamespace::CreateWildcardLoader2());
        return ChainInputLoader<::testing_namespace::Root>::Build(std::move(loaders));
      }().value().release();
  return impl;
}

}  // namespace
}  // namespace my_namespace_GetWildcardMapProtoLoaderImplNamespace

namespace my_namespace {

std::unique_ptr<InputLoader<::testing_namespace::Root>>
GetWildcardMapProtoLoader() {
  return MakeNotOwningInputLoader(
      ::my_namespace_GetWildcardMapProtoLoaderImplNamespace::GetInputLoaderWithWildcards());
}

}  // namespace my_namespace

