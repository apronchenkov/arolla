// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target:
// //arolla/codegen/io/testing:test_dense_array_single_field_repeated_proto_input_loader

#include <memory>

#include "arolla/codegen/io/multi_loader.h"
#include "arolla/dense_array/dense_array.h"
#include "arolla/dense_array/qtype/types.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/proto/test.pb.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/util/map.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace my_namespace_GetDenseArraySingleFieldRepeatedProtoLoaderImplNamespace {

using Input = ::testing_namespace::Root;

namespace {
namespace {

namespace multi_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;
using ::arolla::codegen::io::NamedTypesBuilder;

// In this namespace protopath inputs with `DenseArray` are being loaded.

using HierarchicalMultiValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalMultiValueRequestedInputsData<
        /*kLeafCount=*/1,
        /*kNodeCount=*/2>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalMultiValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:
  // protopath=`ys[:]` name=`ys`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type =
        std::decay_t<decltype(std::declval<const Input&>().ys(0))>;
    using result_type =
        HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[0], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }
};

using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;

// Traverse the proto and put results for all DenaseArray values to the frame.
class SlotSetter {
 public:
  // Returns total size of the array for
  // protopath=`ys[:]` name=`ys`
  size_t TotalSize0() const {
    const auto* start_ptr = single_.intermediate0;
    return start_ptr == nullptr ? 0 : (*start_ptr).ys().size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`ys[:]` name=`ys`
  void CollectResultFromIntermediate0(ResultType_0* output,
                                      RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize0();
    using ValueT = ResultType_0::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`ROOT`
    // Loop is always one or zero iterations, we use a loop to use "continue".
    for (const auto* intermediate_ptr = single_.intermediate0;
         intermediate_ptr != nullptr; intermediate_ptr = nullptr) {
      const auto& tmp_1 = *intermediate_ptr;

      for (const auto& tmp_0 : tmp_1.ys()) {
        inserter.Add(tmp_0);
      }
    }

    *output =
        ResultType_0{std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  void CollectResults(const Input& input, const OutputProvider& outputs,
                      RawBufferFactory* buffer_factory) {
    single_.intermediate0 = &input;

    // protopath=`ys[:]` name=`ys`
    if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[0];
        offset != kSkippedOffset) {
      CollectResultFromIntermediate0(outputs.GetMutable0(offset),
                                     buffer_factory);
    }
  }

 private:
  // Intermediate non vector data: pointers to messages and sizes.
  struct SingleValueData {
    const Input* intermediate0 = nullptr;
  };

  // Intermediate vector data: collection of pointers to messages.
  struct MultiValueData {};

  SingleValueData single_;
  MultiValueData multi_;
};

// InputLoader for all DenseArray value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
      : StaticInputLoader<Input>(
            // use special builder to reduce binary size and stack pressure
            []() {
              NamedTypesBuilder builder;
              builder.Add(R"RL_CODEGEN_DELIM(ys)RL_CODEGEN_DELIM",
                          ::arolla::GetQType<ResultType_0>());
              return std::move(builder).Build();
            }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(
        auto optional_slots,
        ::arolla::MaybeFindSlotsAndVerifyTypes(types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalMultiValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(2);
      tree[1] = {0};
      return tree;
    }();
    CreateHierarchicalMultiValueRequestedInputs(optional_slots, tree,
                                                inputs.get());
    return BoundInputLoader<Input>(
        [inputs = std::move(*inputs)](const Input& input, FramePtr frame,
                                      RawBufferFactory* buffer_factory) {
          OutputProvider output_getter{&inputs, frame};
          SlotSetter slot_setter;
          slot_setter.CollectResults(input, output_getter, buffer_factory);
          return OkStatus();
        });
  }
};

}  // namespace multi_value_protopath
}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(static_cast<InputLoader<Input>*>(
              new multi_value_protopath::Loader())))
          ->release();
  return impl;
}
}  // namespace

namespace {

constexpr auto GetAllShardsInputLoader =
    ::my_namespace_GetDenseArraySingleFieldRepeatedProtoLoaderImplNamespace::
        GetCollectionInputLoader;

}  // namespace
}  // namespace
   // my_namespace_GetDenseArraySingleFieldRepeatedProtoLoaderImplNamespace

namespace my_namespace {

std::unique_ptr<InputLoader<::testing_namespace::Root>>
GetDenseArraySingleFieldRepeatedProtoLoader() {
  return MakeNotOwningInputLoader(
      ::my_namespace_GetDenseArraySingleFieldRepeatedProtoLoaderImplNamespace::
          GetAllShardsInputLoader());
}

}  // namespace my_namespace
