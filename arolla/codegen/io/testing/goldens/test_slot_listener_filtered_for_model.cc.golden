// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_slot_listener_filtered_for_model
#include <functional>
#include <optional>

#include "arolla/codegen/io/multi_loader.h"
#include "arolla/proto/test.pb.h"
#include "arolla/proto/types.h"
#include "arolla/util/map.h"
#include "arolla/io/slot_listener.h"
#include "arolla/util/status.h"
#include "arolla/memory/frame.h"
#include "arolla/io/chain_slot_listener.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/qtype/typed_slot.h"
#include "absl/strings/string_view.h"
#include "arolla/util/meta.h"

namespace {
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundSlotListener;
using ::arolla::ConstFramePtr;
using ::arolla::FrameLayout;
using ::arolla::GetQType;
using ::arolla::QTypePtr;
using ::arolla::TypedSlot;
}

namespace my_namespace_GetFilteredSlotListenerImplNamespace {
namespace {

using Output = ::testing_namespace::Root;



namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;
using ::arolla::codegen::io::NamedTypesBuilder;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being processed.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/4,
        /*kNodeCount=*/5>;

// Provides access to the references inside the frame for each leaf.
class OutputGetter {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_outputs;
  ConstFramePtr frame;

 public:

  // protopath=`x3` name=`bit0_plus1`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get0(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x3())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[0],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x6` name=`bit0_self`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get1(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x6())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[1],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x0` name=`plus1_bit0`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get2(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x0())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[2],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`x4` name=`self_bit0`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get3(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x4())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[3],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

};


using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get3(0))>>;

// Traverse the proto and put results for all single values from the frame.
class SlotReader {
 public:

 void CollectResults(Output& output, const OutputGetter& inputs) {
   Output& tmp_0 = output;

    // protopath=`x3` name=`bit0_plus1`
    [&]() {
      if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        const auto& input = inputs.Get0(offset);
        using proto_type = std::decay_t<decltype(
                std::declval<Output&>().x3())>;
        if (input.present) {
          tmp_0.set_x3(proto_type(input.value));
        }
      }
    }();
    // protopath=`x6` name=`bit0_self`
    [&]() {
      if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[1];
          offset != kSkippedOffset) {
        const auto& input = inputs.Get1(offset);
        using proto_type = std::decay_t<decltype(
                std::declval<Output&>().x6())>;
        if (input.present) {
          tmp_0.set_x6(proto_type(input.value));
        }
      }
    }();
    // protopath=`x0` name=`plus1_bit0`
    [&]() {
      if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[2];
          offset != kSkippedOffset) {
        const auto& input = inputs.Get2(offset);
        using proto_type = std::decay_t<decltype(
                std::declval<Output&>().x0())>;
        if (input.present) {
          tmp_0.set_x0(proto_type(input.value));
        }
      }
    }();
    // protopath=`x4` name=`self_bit0`
    [&]() {
      if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[3];
          offset != kSkippedOffset) {
        const auto& input = inputs.Get3(offset);
        using proto_type = std::decay_t<decltype(
                std::declval<Output&>().x4())>;
        if (input.present) {
          tmp_0.set_x4(proto_type(input.value));
        }
      }
    }();
  }
};

// SlotListener for all single value protopathes.
class Listener final : public ::arolla::StaticSlotListener<Output> {
 public:
  Listener()
    :input_types_in_order_(
      // use special builder to reduce binary size and stack pressure
      []() {
        NamedTypesBuilder builder;
        builder.Add("bit0_plus1", GetQType<ResultType_0>());
        builder.Add("bit0_self", GetQType<ResultType_1>());
        builder.Add("plus1_bit0", GetQType<ResultType_2>());
        builder.Add("self_bit0", GetQType<ResultType_3>());
        return std::move(builder).Build();
      }()),
     input_types_(input_types_in_order_.begin(), input_types_in_order_.end()) {}

  const absl::flat_hash_map<std::string, QTypePtr>& GetTypes() const final {
    return input_types_;
  }

 private:
  StatusOr<BoundSlotListener<Output>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& input_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         input_types_in_order_, input_slots));
    // Allocate on heap to reduce stack pressure.
    auto outputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(5);
      tree[4] = {0,1,2,3};
      return tree;
    }();
    CreateHierarchicalSingleValueRequestedInputs(
      optional_slots,
      /*size_leaves=*/{  },
      tree,
      outputs.get());
    return [outputs=std::move(*outputs)](
        ConstFramePtr frame, Output* output) {
      OutputGetter output_getter{&outputs, frame};
      SlotReader slot_reader;
      slot_reader.CollectResults(*output, output_getter);
      return absl::OkStatus();
    };
  }

  std::vector<std::pair<std::string, QTypePtr>> input_types_in_order_;
  absl::flat_hash_map<std::string, QTypePtr> input_types_;
};

}  // namespace single_value_protopath

}  // namespace
}  // namespace my_namespace_GetFilteredSlotListenerImplNamespace

namespace my_namespace {

std::unique_ptr<::arolla::SlotListener<::testing_namespace::Root>>
GetFilteredSlotListener() {
  static auto* impl = ::arolla::ChainSlotListener<::testing_namespace::Root>::Build(
      std::make_unique<my_namespace_GetFilteredSlotListenerImplNamespace::single_value_protopath::Listener>()
  ).value().release();
  return ::arolla::MakeNotOwningSlotListener(impl);
}

}  // namespace my_namespace

