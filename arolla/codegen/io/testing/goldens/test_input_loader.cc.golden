// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_input_loader


#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::InputLoaderPtr;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace my_namespace_GetLoaderImplNamespace {

using Input = int;

namespace {
namespace {
// Special value to mark not requested slot.
constexpr size_t kSkippedOffset = std::numeric_limits<size_t>::max();

constexpr auto accessor_lambda_0 = [](const auto& input) { return input & 1; };
using AccessorResultType_0 = ::arolla::InputLoaderAccessorResultType<
    decltype(accessor_lambda_0), Input>;

constexpr auto accessor_lambda_1 = [](const auto& input) { return input * 1.0; };
using AccessorResultType_1 = ::arolla::InputLoaderAccessorResultType<
    decltype(accessor_lambda_1), Input>;

constexpr auto accessor_lambda_2 = [](const auto& input) { return input; };
using AccessorResultType_2 = ::arolla::InputLoaderAccessorResultType<
    decltype(accessor_lambda_2), Input>;


// Calling all accessors and put results to the frame.
struct AccessorsSlotSetter {
  // kSkippedOffset means a skipped slot
  size_t offsets[3];
  // true iff at least one slot in the group of size 8 is present
  bool offset_group_present[1] = {false};

  Status operator()(
      const Input& input, FramePtr frame, RawBufferFactory* factory) const {
    if (offset_group_present[0]) {
      if (size_t offset = offsets[0]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_0, input, factory,
            frame.GetMutable(::arolla::FrameLayout::Slot<
                AccessorResultType_0>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[1]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_1, input, factory,
            frame.GetMutable(::arolla::FrameLayout::Slot<
                AccessorResultType_1>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[2]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_2, input, factory,
            frame.GetMutable(::arolla::FrameLayout::Slot<
                AccessorResultType_2>::UnsafeSlotFromOffset(offset)));
      }
    }
    return OkStatus();
  }
};

// InputLoader based on accessors.
class AccessorsLoader final : public ::arolla::StaticInputLoader<Input> {
 public:
  AccessorsLoader()
    : ::arolla::StaticInputLoader<Input>(
          // avoid using initializer_list to reduce stack pressure
          []() {
            std::vector<std::pair<std::string, QTypePtr>> result(3);
            // Note: `result[i] =` is more binary size efficient as `emplace_back`.
            result[0] = {
                R"RL_CODEGEN_DELIM(bit["0"])RL_CODEGEN_DELIM",
                ::arolla::GetQType<AccessorResultType_0>()
            };
            result[1] = {
                R"RL_CODEGEN_DELIM(double)RL_CODEGEN_DELIM",
                ::arolla::GetQType<AccessorResultType_1>()
            };
            result[2] = {
                R"RL_CODEGEN_DELIM(self)RL_CODEGEN_DELIM",
                ::arolla::GetQType<AccessorResultType_2>()
            };
            return result;
          }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         this->types_in_order(), output_slots));
    AccessorsSlotSetter fn;
    for (size_t i = 0; i != 3; ++i) {
      auto slot = optional_slots[i];
      fn.offsets[i] =
          slot.has_value() ? slot->byte_offset() : kSkippedOffset;
      if (slot.has_value()) {
        fn.offset_group_present[i / 8] = true;
      }
    }
    return BoundInputLoader<Input>(fn);
  }
};
}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>*
GetCollectionInputLoader() {
  static const InputLoader<Input>* impl = ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(static_cast<const InputLoader<Input>*>(
            new AccessorsLoader()))
      )->release();
  return impl;
}
}  // namespace


namespace {

constexpr auto GetAllShardsInputLoader =
    ::my_namespace_GetLoaderImplNamespace::GetCollectionInputLoader;

}  // namespace
}  // namespace my_namespace_GetLoaderImplNamespace

namespace my_namespace {

::arolla::InputLoaderPtr<int>
GetLoader() {
  return MakeNotOwningInputLoader(
      ::my_namespace_GetLoaderImplNamespace::GetAllShardsInputLoader());
}

}  // namespace my_namespace

