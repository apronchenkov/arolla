// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_struct_slot_listener

#include <functional>
#include <optional>

#include "arolla/codegen/io/multi_loader.h"
#include "arolla/codegen/io/testing/test_native_struct.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/util/map.h"
#include "arolla/util/text.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/slot_listener.h"
#include "arolla/util/status.h"
#include "arolla/memory/frame.h"
#include "arolla/io/chain_slot_listener.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/qtype/typed_slot.h"
#include "absl/strings/string_view.h"
#include "arolla/util/meta.h"

namespace {
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundSlotListener;
using ::arolla::ChainSlotListener;
using ::arolla::ConstFramePtr;
using ::arolla::FrameLayout;
using ::arolla::GetQType;
using ::arolla::QTypePtr;
using ::arolla::SlotListener;
using ::arolla::TypedSlot;
}

namespace my_namespace_GetStructListenerImplNamespace {

using Output = ::testing_namespace::RootNativeStruct;

namespace {
namespace {


namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being processed.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/5,
        /*kNodeCount=*/9>;

// Provides access to the references inside the frame for each leaf.
class OutputGetter {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_outputs;
  ConstFramePtr frame;

 public:

  // protopath=`&::inner/*/&::a` name=`/inner/a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get0(size_t offset) const {
    using value_type = std::decay_t<decltype(
        (*(std::declval<Output&>().inner)).a)>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[0],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`&::inner_proto/a` name=`/inner_proto/a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get1(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().inner_proto.a())>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[1],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`&::x` name=`/x`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get2(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().x)>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[2],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`&::raw_bytes` name=`raw_bytes`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get3(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<Output&>().raw_bytes)>;
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[3],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`&::str` name=`str`
  ABSL_ATTRIBUTE_ALWAYS_INLINE const auto& Get4(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_outputs->common.leaf_frame_offsets[4],
        kSkippedOffset);
    return frame.Get(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

};


using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get3(0))>>;
using ResultType_4 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputGetter>().Get4(0))>>;

// Traverse the proto and put results for all single values from the frame.
class SlotReader {
 public:

 void CollectResults(Output& output, const OutputGetter& inputs) {
   Output& tmp_3 = output;

    // protopath=`&::inner`
    [&]() {
      if (!inputs.requested_outputs->common.node_requested[1]) {
        return;
      }
      auto& tmp_1 = tmp_3.inner;
      // protopath=`&::inner/*`
      if (!(tmp_1 != nullptr)) {
        return;
      }
      auto& tmp_0 = (*(tmp_1));
      // protopath=`&::inner/*/&::a` name=`/inner/a`
      if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        const auto& input = inputs.Get0(offset);
        using proto_type = std::decay_t<decltype(
                (*(std::declval<Output&>().inner)).a)>;
        if (input.present) {
          tmp_0.a = proto_type(input.value);
        }
      }
    }();
    // protopath=`&::inner_proto`
    [&]() {
      if (!inputs.requested_outputs->common.node_requested[2]) {
        return;
      }
      auto& tmp_2 = tmp_3.inner_proto;
      // protopath=`&::inner_proto/a` name=`/inner_proto/a`
      if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[1];
          offset != kSkippedOffset) {
        const auto& input = inputs.Get1(offset);
        using proto_type = std::decay_t<decltype(
                std::declval<Output&>().inner_proto.a())>;
        if (input.present) {
          tmp_2.set_a(proto_type(input.value));
        }
      }
    }();
    // protopath=`&::x` name=`/x`
    [&]() {
      if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[2];
          offset != kSkippedOffset) {
        const auto& input = inputs.Get2(offset);
        using proto_type = std::decay_t<decltype(
                std::declval<Output&>().x)>;
        if (input.present) {
          tmp_3.x = proto_type(input.value);
        }
      }
    }();
    // protopath=`&::raw_bytes` name=`raw_bytes`
    [&]() {
      if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[3];
          offset != kSkippedOffset) {
        const auto& input = inputs.Get3(offset);
        using proto_type = std::decay_t<decltype(
                std::declval<Output&>().raw_bytes)>;
        if (input.present) {
          tmp_3.raw_bytes = proto_type(input.value);
        }
      }
    }();
    // protopath=`&::str` name=`str`
    [&]() {
      if (size_t offset = inputs.requested_outputs->common.leaf_frame_offsets[4];
          offset != kSkippedOffset) {
        const auto& input = inputs.Get4(offset);
        using proto_type = std::decay_t<decltype(
                std::declval<Output&>().str)>;
        if (input.present) {
          tmp_3.str = proto_type(input.value);
        }
      }
    }();
  }
};

// SlotListener for all single value protopathes.
class Listener final : public ::arolla::StaticSlotListener<Output> {
 public:
  Listener()
    :StaticSlotListener(
        // Use special builder to reduce binary size and stack pressure.
        []() {
          ::arolla::codegen::NamedQTypeVectorBuilder builder;
          builder.AddFromCommonPrefixWithPrevious(
              // /inner/a
              8,
              R"RL_CODEGEN_DELIM(/inner/a)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_0>());
          builder.AddFromCommonPrefixWithPrevious(
              // /inner_proto/a
              14,
              R"RL_CODEGEN_DELIM(_proto/a)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_1>());
          builder.AddFromCommonPrefixWithPrevious(
              // /x
              2,
              R"RL_CODEGEN_DELIM(x)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_2>());
          builder.AddFromCommonPrefixWithPrevious(
              // raw_bytes
              9,
              R"RL_CODEGEN_DELIM(raw_bytes)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_3>());
          builder.AddFromCommonPrefixWithPrevious(
              // str
              3,
              R"RL_CODEGEN_DELIM(str)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_4>());
          return std::move(builder).Build();
        }()) {}

 private:
  auto CreateProtopathTree() const {
    return []() {
      std::vector<std::vector<size_t>> tree(9);
      tree[1] = {0};
      tree[2] = {1};
      tree[4] = {3};
      tree[8] = {2,4,5,6,7};
      return tree;
    }();
  }

  StatusOr<BoundSlotListener<Output>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& input_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         types_in_order(), input_slots));
    // Allocate on heap to reduce stack pressure.
    auto outputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = CreateProtopathTree();
    CreateHierarchicalSingleValueRequestedInputs(
      optional_slots,
      /*size_leaves=*/{  },
      tree,
      outputs.get());
    return [outputs=std::move(outputs)](
        ConstFramePtr frame, Output* output) {
      OutputGetter output_getter{outputs.get(), frame};
      SlotReader slot_reader;
      slot_reader.CollectResults(*output, output_getter);
      return absl::OkStatus();
    };
  }
};

}  // namespace single_value_protopath

}  // namespace

const SlotListener<Output>*
GetCollectionSlotListener() {
  static const SlotListener<Output>* impl = ChainSlotListener<Output>::Build(
      std::make_unique<single_value_protopath::Listener>()
      )->release();
  return impl;
}
}  // namespace
}  // namespace my_namespace_GetStructListenerImplNamespace

namespace my_namespace {

std::unique_ptr<::arolla::SlotListener<::testing_namespace::RootNativeStruct>>
GetStructListener() {
  return MakeNotOwningSlotListener(::my_namespace_GetStructListenerImplNamespace::GetCollectionSlotListener());
}

}  // namespace my_namespace

