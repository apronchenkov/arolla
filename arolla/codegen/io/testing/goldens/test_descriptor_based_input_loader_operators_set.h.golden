// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib

#include <memory>

#include "arolla/codegen/io/testing/test_proto_qtype.h"
#include "arolla/proto/testing/test.pb.h"
#include "arolla/proto/testing/test_proto3.pb.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/qtype/base_types.h"


namespace my_namespace {

struct LoadFromProtoDescriptorBasedFunctor0/*/root/BrOkEn_CaSe*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).broken_case())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, broken_case))) { return; }
  const auto& final_result = val_1.broken_case();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor1/*/root/inner/a*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).inner().a())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, inner))) { return; }
  const auto& val_2 = val_1.inner();
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_2, a))) { return; }
  const auto& final_result = val_2.a();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor2/*/root/inner/bytes_cord*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).inner().bytes_cord())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, inner))) { return; }
  const auto& val_2 = val_1.inner();
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_2, bytes_cord))) { return; }
  const auto& final_result = val_2.bytes_cord();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor3/*/root/inner/inner2/z*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).inner().inner2().z())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, inner))) { return; }
  const auto& val_2 = val_1.inner();
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_2, inner2))) { return; }
  const auto& val_3 = val_2.inner2();
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_3, z))) { return; }
  const auto& final_result = val_3.z();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor4/*/root/inner/raw_bytes*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).inner().raw_bytes())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, inner))) { return; }
  const auto& val_2 = val_1.inner();
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_2, raw_bytes))) { return; }
  const auto& final_result = val_2.raw_bytes();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor5/*/root/inner/str*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<::arolla::Text>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, inner))) { return; }
  const auto& val_2 = val_1.inner();
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_2, str))) { return; }
  const auto& final_result = val_2.str();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor6/*/root/inner/str_cord*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<::arolla::Text>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, inner))) { return; }
  const auto& val_2 = val_1.inner();
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_2, str_cord))) { return; }
  const auto& final_result = val_2.str_cord();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor7/*/root/private*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).private_())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, private_))) { return; }
  const auto& final_result = val_1.private_();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor8/*/root/proto3/non_optional_i32*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).proto3().non_optional_i32())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, proto3))) { return; }
  const auto& val_2 = val_1.proto3();
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_2, non_optional_i32))) { return; }
  const auto& final_result = val_2.non_optional_i32();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor9/*/root/raw_bytes*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).raw_bytes())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, raw_bytes))) { return; }
  const auto& final_result = val_1.raw_bytes();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor10/*/root/str*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<::arolla::Text>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, str))) { return; }
  const auto& final_result = val_1.str();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor11/*/root/x*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x))) { return; }
  const auto& final_result = val_1.x();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor12/*/root/x0*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x0())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x0))) { return; }
  const auto& final_result = val_1.x0();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor13/*/root/x1*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x1())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x1))) { return; }
  const auto& final_result = val_1.x1();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor14/*/root/x2*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x2())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x2))) { return; }
  const auto& final_result = val_1.x2();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor15/*/root/x3*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x3())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x3))) { return; }
  const auto& final_result = val_1.x3();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor16/*/root/x4*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x4())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x4))) { return; }
  const auto& final_result = val_1.x4();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor17/*/root/x5*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x5())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x5))) { return; }
  const auto& final_result = val_1.x5();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor18/*/root/x6*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x6())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x6))) { return; }
  const auto& final_result = val_1.x6();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor19/*/root/x7*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x7())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x7))) { return; }
  const auto& final_result = val_1.x7();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor20/*/root/x8*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x8())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x8))) { return; }
  const auto& final_result = val_1.x8();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor21/*/root/x9*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x9())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x9))) { return; }
  const auto& final_result = val_1.x9();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor22/*/root/x_bytes_cord*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x_bytes_cord())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x_bytes_cord))) { return; }
  const auto& final_result = val_1.x_bytes_cord();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor23/*/root/x_double*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x_double())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x_double))) { return; }
  const auto& final_result = val_1.x_double();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor24/*/root/x_enum*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x_enum())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x_enum))) { return; }
  const auto& final_result = val_1.x_enum();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor25/*/root/x_fixed64*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x_fixed64())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x_fixed64))) { return; }
  const auto& final_result = val_1.x_fixed64();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor26/*/root/x_float*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x_float())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x_float))) { return; }
  const auto& final_result = val_1.x_float();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor27/*/root/x_int64*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x_int64())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x_int64))) { return; }
  const auto& final_result = val_1.x_int64();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor28/*/root/x_string_cord*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<::arolla::Text>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x_string_cord))) { return; }
  const auto& final_result = val_1.x_string_cord();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor29/*/root/x_uint32*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x_uint32())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x_uint32))) { return; }
  const auto& final_result = val_1.x_uint32();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromProtoDescriptorBasedFunctor30/*/root/x_uint64*/ {
  auto operator()(const ::testing_namespace::RootRawPtrHolder& input) const {
    static constexpr auto accessor_lambda = [](const ::testing_namespace::RootRawPtrHolder& input,
::arolla::proto::arolla_optional_value_t<decltype((*(input.root)).x_uint64())>* output) {
output->present = false;
  const auto& val_0 = input.root;
  if (!(val_0 != nullptr)) { return; }
  const auto& val_1 = (*(val_0));
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_1, x_uint64))) { return; }
  const auto& final_result = val_1.x_uint64();
        output->present = true;
        output->value = ::arolla::proto::ToArollaCompatibleType(final_result);
  };
    using AccessorResultType = ::arolla::InputLoaderAccessorResultType<
        decltype(accessor_lambda), ::testing_namespace::RootRawPtrHolder>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};

}  // namespace my_namespace
