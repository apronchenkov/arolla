// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target:
// //arolla/codegen/io/testing:test_input_loader_operators_set_lib

#include <memory>

#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/qtype/base_types.h"

namespace my_namespace {

struct LoadFromIntFunctor0 /*bit["0"]*/ {
  auto operator()(const int& input) const {
    static constexpr auto accessor_lambda = [](const auto& input) {
      return input & 1;
    };
    using AccessorResultType =
        ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda), int>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromIntFunctor1 /*double*/ {
  auto operator()(const int& input) const {
    static constexpr auto accessor_lambda = [](const auto& input) {
      return input * 1.0;
    };
    using AccessorResultType =
        ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda), int>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};
struct LoadFromIntFunctor2 /*self*/ {
  auto operator()(const int& input) const {
    static constexpr auto accessor_lambda = [](const auto& input) {
      return input;
    };
    using AccessorResultType =
        ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda), int>;
    AccessorResultType result;
    ::arolla::InvokeInputLoaderAccessor(
        accessor_lambda, input, arolla::GetHeapBufferFactory(), &result);
    return result;
  }
};

}  // namespace my_namespace
