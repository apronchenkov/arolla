// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_repeated_proto_input_loader

#include <memory>


#include "arolla/codegen/io/multi_loader.h"
#include "arolla/codegen/io/testing/test_proto_qtype.h"
#include "arolla/dense_array/dense_array.h"
#include "arolla/dense_array/qtype/types.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/proto/testing/test.pb.h"
#include "arolla/qtype/qtype.h"
#include "arolla/util/bytes.h"
#include "arolla/util/map.h"
#include "arolla/util/text.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/qtype/base_types.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace my_namespace_GetRepeatedProtoLoaderImplNamespace {

using Input = ::testing_namespace::Root;

namespace {
namespace {
namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being loaded.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/2,
        /*kNodeCount=*/3>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:

  // protopath=`count(inners[:])` name=`inners_size`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::size_type;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[0],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`count(map_inner[:])` name=`map_inner_size`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using result_type = HierarchicalSingleValueRequestedInputs::size_type;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[1],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

};


using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;

// Traverse the proto and put results for all single values to the frame.
class SlotSetter {
 public:

 void CollectResults(const Input& input, const OutputProvider& outputs) {
   const Input& tmp_0 = input;

    // protopath=`count(inners[:])` name=`inners_size`
    [&]() {
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        *outputs.GetMutable0(offset) = ::arolla::DenseArrayShape{
            static_cast<int64_t>(tmp_0.inners().size())};
      }
    }();
    // protopath=`count(map_inner[:])` name=`map_inner_size`
    [&]() {
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[1];
          offset != kSkippedOffset) {
        *outputs.GetMutable1(offset) = ::arolla::DenseArrayShape{
            static_cast<int64_t>(tmp_0.map_inner().size())};
      }
    }();
  }
};

// InputLoader for all single value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
    : ::arolla::StaticInputLoader<Input>(
        // Use special builder to reduce binary size and stack pressure.
        []() {
          ::arolla::codegen::NamedQTypeVectorBuilder builder;
          builder.AddFromCommonPrefixWithPrevious(
              // inners_size
              11,
              R"RL_CODEGEN_DELIM(inners_size)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_0>());
          builder.AddFromCommonPrefixWithPrevious(
              // map_inner_size
              14,
              R"RL_CODEGEN_DELIM(map_inner_size)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_1>());
          return std::move(builder).Build();
        }()) {}

 private:
  auto CreateProtopathTree() const {
    return []() {
      std::vector<std::vector<size_t>> tree(3);
      tree[2] = {0,1};
      return tree;
    }();
  }

  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = CreateProtopathTree();
    CreateHierarchicalSingleValueRequestedInputs(
      optional_slots,
      /*size_leaves=*/{ 0, 1 },
      tree,
      inputs.get());
    return BoundInputLoader<Input>([inputs=std::move(inputs)](
        const Input& input, FramePtr frame, RawBufferFactory*) {
      OutputProvider output_getter{inputs.get(), frame};
      SlotSetter slot_setter;
      slot_setter.CollectResults(input, output_getter);
      return OkStatus();
    });
  }
};

}  // namespace single_value_protopath

namespace multi_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;

// In this namespace protopath inputs with `DenseArray` are being loaded.

using HierarchicalMultiValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalMultiValueRequestedInputsData<
        /*kLeafCount=*/14,
        /*kNodeCount=*/24>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalMultiValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:

  // protopath=`inners[:]/&` name=`/inners`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type = std::decay_t<decltype(
        (&(std::declval<const Input&>().inners(0))))>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[0],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/a` name=`inners__a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).a())>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[1],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/as[:]` name=`inners__as`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).as(0))>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[2],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/as[1]` name=`inners__as1`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).as(1))>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[3],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/count(as[:])` name=`inners__as_size`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable4(size_t offset) const {
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<
        ::arolla::proto::arolla_size_t>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[4],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/inner2/z` name=`inners__inner2__z`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable5(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).inner2().z())>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[5],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/raw_bytes` name=`inners__raw_bytes`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable6(size_t offset) const {
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<
        ::arolla::Bytes>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[6],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/str` name=`inners__str`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable7(size_t offset) const {
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<
        ::arolla::Text>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[7],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inner/as[:]` name=`inner__as`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable8(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inner().as(0))>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[8],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[1]/as[:]` name=`inners1__as`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable9(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(1).as(0))>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[9],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`map_inner[:]@key` name=`map_inner__keys`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable10(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().map_inner().begin()->first)>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[10],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`map_inner[:]@value/a` name=`map_inner__value_a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable11(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().map_inner().begin()->second.a())>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[11],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`self_reference/self_reference/self_reference/inners[:]/as[:]` name=`sr3_inners_as`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable12(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().self_reference().self_reference().self_reference().inners(0).as(0))>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[12],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`ys[:]` name=`ys`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable13(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().ys(0))>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[13],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

};


using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;
using ResultType_4 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable4(0))>>;
using ResultType_5 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable5(0))>>;
using ResultType_6 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable6(0))>>;
using ResultType_7 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable7(0))>>;
using ResultType_8 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable8(0))>>;
using ResultType_9 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable9(0))>>;
using ResultType_10 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable10(0))>>;
using ResultType_11 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable11(0))>>;
using ResultType_12 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable12(0))>>;
using ResultType_13 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable13(0))>>;

// Traverse the proto and put results for all DenaseArray values to the frame.
class SlotSetter {
 public:
  // Collects all intermediate results and sizes we need for further individual
  // DenseArray creation.
  // Fills `single_` and `intermediate*_`.
  void CollectIntermediateResults(
     const Input& input,
     const HierarchicalMultiValueRequestedInputs& requested_inputs) {
   const Input& tmp_9 = input;

    // protopath=`inners[:]`
    [&]() {
      if (!requested_inputs.common.node_requested[1]) {
        return;
      }
      multi_.intermediate1.reserve(tmp_9.inners().size());

      for (const auto& tmp_1 : tmp_9.inners()) {
        multi_.intermediate1.push_back(nullptr);
        multi_.intermediate1.back() = &tmp_1;
        // protopath=`inners[:]/as[:]` name=`inners__as`
        single_.total_size_2 +=
            tmp_1.as().size();
      }
    }();

    // protopath=`inner`
    [&]() {
      if (!requested_inputs.common.node_requested[2]) {
        return;
      }
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_9, inner))) {
        return;
      }
      const auto& tmp_2 = tmp_9.inner();
      single_.intermediate2 = &tmp_2;
    }();

    // protopath=`inners[1]`
    [&]() {
      if (!requested_inputs.common.node_requested[3]) {
        return;
      }
      if (!(tmp_9.inners().size() > 1)) {
        return;
      }
      const auto& tmp_3 = tmp_9.inners(1);
      single_.intermediate3 = &tmp_3;
    }();



    // protopath=`self_reference`
    [&]() {
      if (!requested_inputs.common.node_requested[8]) {
        return;
      }
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_9, self_reference))) {
        return;
      }
      const auto& tmp_8 = tmp_9.self_reference();
      // protopath=`self_reference/self_reference`
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_8, self_reference))) {
        return;
      }
      const auto& tmp_7 = tmp_8.self_reference();
      // protopath=`self_reference/self_reference/self_reference`
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_7, self_reference))) {
        return;
      }
      const auto& tmp_6 = tmp_7.self_reference();
      // protopath=`self_reference/self_reference/self_reference/inners[:]`
      multi_.intermediate5.reserve(tmp_6.inners().size());

      for (const auto& tmp_5 : tmp_6.inners()) {
        multi_.intermediate5.push_back(nullptr);
        multi_.intermediate5.back() = &tmp_5;
        // protopath=`self_reference/self_reference/self_reference/inners[:]/as[:]` name=`sr3_inners_as`
        single_.total_size_17 +=
            tmp_5.as().size();
      }
    }();

  }
  // Returns total size of the array for
  // protopath=`inners[:]/&` name=`/inners`
  size_t TotalSize0() const {
    return multi_.intermediate1.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/&` name=`/inners`
  void CollectResultFromIntermediate0(
      ResultType_0* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize0();
    using ValueT = ResultType_0::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]`
    for (const auto* intermediate_ptr : multi_.intermediate1) {
      const auto& tmp_9 = *intermediate_ptr;
      const auto& tmp_0 = (&(tmp_9));
      inserter.Add(tmp_0);
    }

    *output = ResultType_0{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/a` name=`inners__a`
  size_t TotalSize1() const {
    return multi_.intermediate1.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/a` name=`inners__a`
  void CollectResultFromIntermediate1(
      ResultType_1* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize1();
    using ValueT = ResultType_1::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]`
    for (const auto* intermediate_ptr : multi_.intermediate1) {
      const auto& tmp_9 = *intermediate_ptr;
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_9, a))) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_1 = tmp_9.a();
      id++;
      inserter.Add(tmp_1);
    }

    *output = ResultType_1{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/as[:]` name=`inners__as`
  size_t TotalSize2() const {
    return single_.total_size_2;
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/as[:]` name=`inners__as`
  void CollectResultFromIntermediate2(
      ResultType_2* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize2();
    using ValueT = ResultType_2::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]`
    for (const auto* intermediate_ptr : multi_.intermediate1) {
      const auto& tmp_9 = *intermediate_ptr;

      for (const auto& tmp_2 : tmp_9.as()) {
        inserter.Add(tmp_2);
      }
    }

    *output = ResultType_2{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/as[1]` name=`inners__as1`
  size_t TotalSize3() const {
    return multi_.intermediate1.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/as[1]` name=`inners__as1`
  void CollectResultFromIntermediate3(
      ResultType_3* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize3();
    using ValueT = ResultType_3::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]`
    for (const auto* intermediate_ptr : multi_.intermediate1) {
      const auto& tmp_9 = *intermediate_ptr;
      if (!(tmp_9.as().size() > 1)) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_3 = tmp_9.as(1);
      id++;
      inserter.Add(tmp_3);
    }

    *output = ResultType_3{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/count(as[:])` name=`inners__as_size`
  size_t TotalSize4() const {
    return multi_.intermediate1.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/count(as[:])` name=`inners__as_size`
  void CollectResultFromIntermediate4(
      ResultType_4* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize4();
    using ValueT = ResultType_4::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]`
    for (const auto* intermediate_ptr : multi_.intermediate1) {
      const auto& tmp_9 = *intermediate_ptr;
      const auto& tmp_4 = tmp_9.as().size();
      inserter.Add(tmp_4);
    }

    *output = ResultType_4{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/inner2/z` name=`inners__inner2__z`
  size_t TotalSize5() const {
    return multi_.intermediate1.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/inner2/z` name=`inners__inner2__z`
  void CollectResultFromIntermediate5(
      ResultType_5* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize5();
    using ValueT = ResultType_5::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]`
    for (const auto* intermediate_ptr : multi_.intermediate1) {
      const auto& tmp_9 = *intermediate_ptr;
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_9, inner2))) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_6 = tmp_9.inner2();

      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_6, z))) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_5 = tmp_6.z();
      id++;
      inserter.Add(tmp_5);
    }

    *output = ResultType_5{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/raw_bytes` name=`inners__raw_bytes`
  size_t TotalSize6() const {
    return multi_.intermediate1.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/raw_bytes` name=`inners__raw_bytes`
  void CollectResultFromIntermediate6(
      ResultType_6* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize6();
    using ValueT = ResultType_6::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]`
    for (const auto* intermediate_ptr : multi_.intermediate1) {
      const auto& tmp_9 = *intermediate_ptr;
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_9, raw_bytes))) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_7 = tmp_9.raw_bytes();
      id++;
      inserter.Add(tmp_7);
    }

    *output = ResultType_6{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/str` name=`inners__str`
  size_t TotalSize7() const {
    return multi_.intermediate1.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/str` name=`inners__str`
  void CollectResultFromIntermediate7(
      ResultType_7* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize7();
    using ValueT = ResultType_7::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]`
    for (const auto* intermediate_ptr : multi_.intermediate1) {
      const auto& tmp_9 = *intermediate_ptr;
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_9, str))) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_8 = tmp_9.str();
      id++;
      inserter.Add(tmp_8);
    }

    *output = ResultType_7{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inner/as[:]` name=`inner__as`
  size_t TotalSize8() const {
    const auto* start_ptr = single_.intermediate2;
    return start_ptr == nullptr ? 0 :
           (*start_ptr).as().size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inner/as[:]` name=`inner__as`
  void CollectResultFromIntermediate8(
      ResultType_8* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize8();
    using ValueT = ResultType_8::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inner`
    // Loop is always one or zero iterations, we use a loop to use "continue".
    for (const auto* intermediate_ptr = single_.intermediate2;
         intermediate_ptr != nullptr;
         intermediate_ptr = nullptr) {
      const auto& tmp_11 = *intermediate_ptr;

      for (const auto& tmp_10 : tmp_11.as()) {
        inserter.Add(tmp_10);
      }
    }

    *output = ResultType_8{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[1]/as[:]` name=`inners1__as`
  size_t TotalSize9() const {
    const auto* start_ptr = single_.intermediate3;
    return start_ptr == nullptr ? 0 :
           (*start_ptr).as().size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[1]/as[:]` name=`inners1__as`
  void CollectResultFromIntermediate9(
      ResultType_9* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize9();
    using ValueT = ResultType_9::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[1]`
    // Loop is always one or zero iterations, we use a loop to use "continue".
    for (const auto* intermediate_ptr = single_.intermediate3;
         intermediate_ptr != nullptr;
         intermediate_ptr = nullptr) {
      const auto& tmp_13 = *intermediate_ptr;

      for (const auto& tmp_12 : tmp_13.as()) {
        inserter.Add(tmp_12);
      }
    }

    *output = ResultType_9{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`map_inner[:]@key` name=`map_inner__keys`
  size_t TotalSize10() const {
    const auto* start_ptr = single_.intermediate9;
    return start_ptr == nullptr ? 0 :
           (*start_ptr).map_inner().size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`map_inner[:]@key` name=`map_inner__keys`
  void CollectResultFromIntermediate10(
      ResultType_10* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize10();
    using ValueT = ResultType_10::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`ROOT`
    // Loop is always one or zero iterations, we use a loop to use "continue".
    for (const auto* intermediate_ptr = single_.intermediate9;
         intermediate_ptr != nullptr;
         intermediate_ptr = nullptr) {
      const auto& tmp_23 = *intermediate_ptr;

      for (const auto& tmp_14 : ::arolla::SortedMapKeys(tmp_23.map_inner())) {
        inserter.Add(tmp_14);
      }
    }

    *output = ResultType_10{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`map_inner[:]@value/a` name=`map_inner__value_a`
  size_t TotalSize11() const {
    const auto* start_ptr = single_.intermediate9;
    return start_ptr == nullptr ? 0 :
           (*start_ptr).map_inner().size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`map_inner[:]@value/a` name=`map_inner__value_a`
  void CollectResultFromIntermediate11(
      ResultType_11* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize11();
    using ValueT = ResultType_11::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`ROOT`
    // Loop is always one or zero iterations, we use a loop to use "continue".
    for (const auto* intermediate_ptr = single_.intermediate9;
         intermediate_ptr != nullptr;
         intermediate_ptr = nullptr) {
      const auto& tmp_23 = *intermediate_ptr;

      for (const auto& tmp_16_loop_var : ::arolla::SortedMapKeys(tmp_23.map_inner())) {
        const auto& tmp_16 = tmp_23.map_inner().at(tmp_16_loop_var);

        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_16, a))) {
          bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
          continue;
        }
        const auto& tmp_15 = tmp_16.a();
        id++;
        inserter.Add(tmp_15);
      }
    }

    *output = ResultType_11{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`self_reference/self_reference/self_reference/inners[:]/as[:]` name=`sr3_inners_as`
  size_t TotalSize12() const {
    return single_.total_size_17;
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`self_reference/self_reference/self_reference/inners[:]/as[:]` name=`sr3_inners_as`
  void CollectResultFromIntermediate12(
      ResultType_12* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize12();
    using ValueT = ResultType_12::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`self_reference/self_reference/self_reference/inners[:]`
    for (const auto* intermediate_ptr : multi_.intermediate5) {
      const auto& tmp_18 = *intermediate_ptr;

      for (const auto& tmp_17 : tmp_18.as()) {
        inserter.Add(tmp_17);
      }
    }

    *output = ResultType_12{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`ys[:]` name=`ys`
  size_t TotalSize13() const {
    const auto* start_ptr = single_.intermediate9;
    return start_ptr == nullptr ? 0 :
           (*start_ptr).ys().size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`ys[:]` name=`ys`
  void CollectResultFromIntermediate13(
      ResultType_13* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize13();
    using ValueT = ResultType_13::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`ROOT`
    // Loop is always one or zero iterations, we use a loop to use "continue".
    for (const auto* intermediate_ptr = single_.intermediate9;
         intermediate_ptr != nullptr;
         intermediate_ptr = nullptr) {
      const auto& tmp_23 = *intermediate_ptr;

      for (const auto& tmp_22 : tmp_23.ys()) {
        inserter.Add(tmp_22);
      }
    }

    *output = ResultType_13{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }



 void CollectResults(
     const Input& input, const OutputProvider& outputs,
     RawBufferFactory* buffer_factory) {
   single_.intermediate9 = &input;
   CollectIntermediateResults(input, *outputs.requested_inputs);

    // protopath=`inners[:]`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[1]) {
        return;
      }
      // protopath=`inners[:]/&` name=`/inners`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate0(
            outputs.GetMutable0(offset), buffer_factory);
      }
      // protopath=`inners[:]/a` name=`inners__a`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[1];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate1(
            outputs.GetMutable1(offset), buffer_factory);
      }
      // protopath=`inners[:]/as[:]` name=`inners__as`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[2];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate2(
            outputs.GetMutable2(offset), buffer_factory);
      }
      // protopath=`inners[:]/as[1]` name=`inners__as1`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[3];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate3(
            outputs.GetMutable3(offset), buffer_factory);
      }
      // protopath=`inners[:]/count(as[:])` name=`inners__as_size`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[4];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate4(
            outputs.GetMutable4(offset), buffer_factory);
      }
      // protopath=`inners[:]/inner2`
      [&]() {
        if (!outputs.requested_inputs->common.node_requested[0]) {
          return;
        }
        // protopath=`inners[:]/inner2/z` name=`inners__inner2__z`
        if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[5];
            offset != kSkippedOffset) {
          CollectResultFromIntermediate5(
              outputs.GetMutable5(offset), buffer_factory);
        }
      }();
      // protopath=`inners[:]/raw_bytes` name=`inners__raw_bytes`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[6];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate6(
            outputs.GetMutable6(offset), buffer_factory);
      }
      // protopath=`inners[:]/str` name=`inners__str`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[7];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate7(
            outputs.GetMutable7(offset), buffer_factory);
      }
    }();

    // protopath=`inner`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[2]) {
        return;
      }
      // protopath=`inner/as[:]` name=`inner__as`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[8];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate8(
            outputs.GetMutable8(offset), buffer_factory);
      }
    }();

    // protopath=`inners[1]`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[3]) {
        return;
      }
      // protopath=`inners[1]/as[:]` name=`inners1__as`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[9];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate9(
            outputs.GetMutable9(offset), buffer_factory);
      }
    }();

    // protopath=`map_inner[:]@key` name=`map_inner__keys`
    if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[10];
        offset != kSkippedOffset) {
      CollectResultFromIntermediate10(
          outputs.GetMutable10(offset), buffer_factory);
    }

    // protopath=`map_inner[:]@value`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[4]) {
        return;
      }
      // protopath=`map_inner[:]@value/a` name=`map_inner__value_a`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[11];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate11(
            outputs.GetMutable11(offset), buffer_factory);
      }
    }();

    // protopath=`self_reference`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[8]) {
        return;
      }
      // protopath=`self_reference/self_reference`
      // protopath=`self_reference/self_reference/self_reference`
      // protopath=`self_reference/self_reference/self_reference/inners[:]`
      // protopath=`self_reference/self_reference/self_reference/inners[:]/as[:]` name=`sr3_inners_as`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[12];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate12(
            outputs.GetMutable12(offset), buffer_factory);
      }
    }();

    // protopath=`ys[:]` name=`ys`
    if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[13];
        offset != kSkippedOffset) {
      CollectResultFromIntermediate13(
          outputs.GetMutable13(offset), buffer_factory);
    }
 }

 private:
  // Intermediate non vector data: pointers to messages and sizes.
  struct SingleValueData {
    const Input* intermediate9 = nullptr;
    // protopath=`inners[:]/as[:]` name=`inners__as`
    size_t total_size_2 = 0;
    using MsgType2 = std::decay_t<decltype(
        std::declval<const Input&>().inner())>;
    const MsgType2* intermediate2 = nullptr;
    using MsgType3 = std::decay_t<decltype(
        std::declval<const Input&>().inners(1))>;
    const MsgType3* intermediate3 = nullptr;
    // protopath=`self_reference/self_reference/self_reference/inners[:]/as[:]` name=`sr3_inners_as`
    size_t total_size_17 = 0;
  };

  // Intermediate vector data: collection of pointers to messages.
  struct MultiValueData {
    using MsgType1 = std::decay_t<decltype(
        std::declval<const Input&>().inners(0))>;
    std::vector<const MsgType1*> intermediate1;
    using MsgType5 = std::decay_t<decltype(
        std::declval<const Input&>().self_reference().self_reference().self_reference().inners(0))>;
    std::vector<const MsgType5*> intermediate5;
  };

  SingleValueData single_;
  MultiValueData multi_;
};

// InputLoader for all DenseArray value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
    : StaticInputLoader<Input>(
        // Use special builder to reduce binary size and stack pressure.
        []() {
          ::arolla::codegen::NamedQTypeVectorBuilder builder;
          builder.AddFromCommonPrefixWithPrevious(
              // /inners
              7,
              R"RL_CODEGEN_DELIM(/inners)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_0>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners__a
              9,
              R"RL_CODEGEN_DELIM(inners__a)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_1>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners__as
              10,
              R"RL_CODEGEN_DELIM(s)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_2>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners__as1
              11,
              R"RL_CODEGEN_DELIM(1)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_3>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners__as_size
              15,
              R"RL_CODEGEN_DELIM(_size)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_4>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners__inner2__z
              17,
              R"RL_CODEGEN_DELIM(inner2__z)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_5>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners__raw_bytes
              17,
              R"RL_CODEGEN_DELIM(raw_bytes)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_6>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners__str
              11,
              R"RL_CODEGEN_DELIM(str)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_7>());
          builder.AddFromCommonPrefixWithPrevious(
              // inner__as
              9,
              R"RL_CODEGEN_DELIM(__as)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_8>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners1__as
              11,
              R"RL_CODEGEN_DELIM(s1__as)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_9>());
          builder.AddFromCommonPrefixWithPrevious(
              // map_inner__keys
              15,
              R"RL_CODEGEN_DELIM(map_inner__keys)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_10>());
          builder.AddFromCommonPrefixWithPrevious(
              // map_inner__value_a
              18,
              R"RL_CODEGEN_DELIM(value_a)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_11>());
          builder.AddFromCommonPrefixWithPrevious(
              // sr3_inners_as
              13,
              R"RL_CODEGEN_DELIM(sr3_inners_as)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_12>());
          builder.AddFromCommonPrefixWithPrevious(
              // ys
              2,
              R"RL_CODEGEN_DELIM(ys)RL_CODEGEN_DELIM",
              ::arolla::GetQType<ResultType_13>());
          return std::move(builder).Build();
        }()) {}

 private:
  auto CreateProtopathTree() const {
    return []() {
      std::vector<std::vector<size_t>> tree(24);
      tree[6] = {5};
      tree[9] = {0,1,2,3,4,6,7,8};
      tree[11] = {10};
      tree[13] = {12};
      tree[16] = {15};
      tree[18] = {17};
      tree[19] = {18};
      tree[20] = {19};
      tree[21] = {20};
      tree[23] = {9,11,13,14,16,21,22};
      return tree;
    }();
  }

  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalMultiValueRequestedInputs>();
    auto tree = CreateProtopathTree();
    CreateHierarchicalMultiValueRequestedInputs(
      optional_slots,
      tree,
      inputs.get());
    return BoundInputLoader<Input>([inputs=std::move(inputs)](
        const Input& input, FramePtr frame, RawBufferFactory* buffer_factory) {
      OutputProvider output_getter{inputs.get(), frame};
      SlotSetter slot_setter;
      slot_setter.CollectResults(input, output_getter, buffer_factory);
      return OkStatus();
    });
  }
};

}  // namespace multi_value_protopath
}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>*
GetCollectionInputLoader() {
  static const InputLoader<Input>* impl = ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(static_cast<InputLoader<Input>*>(
            new single_value_protopath::Loader())),
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(static_cast<InputLoader<Input>*>(
            new multi_value_protopath::Loader()))
      )->release();
  return impl;
}
}  // namespace


namespace {

constexpr auto GetAllShardsInputLoader =
    ::my_namespace_GetRepeatedProtoLoaderImplNamespace::GetCollectionInputLoader;

}  // namespace
}  // namespace my_namespace_GetRepeatedProtoLoaderImplNamespace

namespace my_namespace {

std::unique_ptr<InputLoader<::testing_namespace::Root>>
GetRepeatedProtoLoader() {
  return MakeNotOwningInputLoader(
      ::my_namespace_GetRepeatedProtoLoaderImplNamespace::GetAllShardsInputLoader());
}

}  // namespace my_namespace

