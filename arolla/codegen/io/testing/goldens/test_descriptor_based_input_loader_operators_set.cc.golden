// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set

#include <memory>


#include "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"
#include "arolla/codegen/io/testing/test_proto_qtype.h"
#include "arolla/proto/testing/test.pb.h"
#include "arolla/proto/testing/test_proto3.pb.h"
#include "arolla/qexpr/operator_metadata.h"
#include "arolla/qexpr/optools.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/expr/lambda_expr_operator.h"
#include "arolla/expr/operator_loader/backend_operator.h"
#include "arolla/expr/registered_expr_operator.h"


namespace my_namespace {
namespace {

// ::my_namespace::LoadFromProtoDescriptorBased
absl::Status RegisterIOOperators0() {
  const arolla::QTypePtr kInputQtype =
      ::arolla::GetQType<::testing_namespace::RootRawPtrHolder>();
  // Register Expr operator for input QType.
  static constexpr absl::string_view kQTypeOperatorName =
      "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_GQTYPE_G_G_R_RGetInputQType";
  RETURN_IF_ERROR(
    ::arolla::expr::RegisterOperator(
        kQTypeOperatorName, arolla::expr::LambdaOperator::Make(
            kQTypeOperatorName,
            arolla::expr::ExprOperatorSignature::MakeArgsN(0),
            arolla::expr::Literal(kInputQtype)))
    .status());

  {  // /root/BrOkEn_CaSe
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_FBrOkEn_RCaSe";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor0/*/root/BrOkEn_CaSe*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor0/*/root/BrOkEn_CaSe*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/inner/a
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Finner_Fa";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor1/*/root/inner/a*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor1/*/root/inner/a*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/inner/bytes_cord
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Finner_Fbytes_Rcord";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor2/*/root/inner/bytes_cord*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor2/*/root/inner/bytes_cord*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/inner/inner2/z
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Finner_Finner2_Fz";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor3/*/root/inner/inner2/z*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor3/*/root/inner/inner2/z*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/inner/raw_bytes
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Finner_Fraw_Rbytes";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor4/*/root/inner/raw_bytes*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor4/*/root/inner/raw_bytes*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/inner/str
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Finner_Fstr";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor5/*/root/inner/str*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor5/*/root/inner/str*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/inner/str_cord
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Finner_Fstr_Rcord";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor6/*/root/inner/str_cord*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor6/*/root/inner/str_cord*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/private
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fprivate";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor7/*/root/private*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor7/*/root/private*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/proto3/non_optional_i32
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fproto3_Fnon_Roptional_Ri32";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor8/*/root/proto3/non_optional_i32*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor8/*/root/proto3/non_optional_i32*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/raw_bytes
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fraw_Rbytes";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor9/*/root/raw_bytes*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor9/*/root/raw_bytes*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/str
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fstr";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor10/*/root/str*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor10/*/root/str*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor11/*/root/x*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor11/*/root/x*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x0
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx0";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor12/*/root/x0*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor12/*/root/x0*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x1
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx1";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor13/*/root/x1*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor13/*/root/x1*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x2
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx2";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor14/*/root/x2*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor14/*/root/x2*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x3
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx3";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor15/*/root/x3*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor15/*/root/x3*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x4
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx4";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor16/*/root/x4*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor16/*/root/x4*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x5
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx5";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor17/*/root/x5*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor17/*/root/x5*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x6
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx6";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor18/*/root/x6*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor18/*/root/x6*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x7
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx7";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor19/*/root/x7*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor19/*/root/x7*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x8
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx8";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor20/*/root/x8*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor20/*/root/x8*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x9
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx9";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor21/*/root/x9*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor21/*/root/x9*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x_bytes_cord
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx_Rbytes_Rcord";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor22/*/root/x_bytes_cord*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor22/*/root/x_bytes_cord*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x_double
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx_Rdouble";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor23/*/root/x_double*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor23/*/root/x_double*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x_enum
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx_Renum";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor24/*/root/x_enum*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor24/*/root/x_enum*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x_fixed64
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx_Rfixed64";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor25/*/root/x_fixed64*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor25/*/root/x_fixed64*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x_float
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx_Rfloat";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor26/*/root/x_float*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor26/*/root/x_float*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x_int64
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx_Rint64";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor27/*/root/x_int64*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor27/*/root/x_int64*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x_string_cord
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx_Rstring_Rcord";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor28/*/root/x_string_cord*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor28/*/root/x_string_cord*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x_uint32
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx_Ruint32";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor29/*/root/x_uint32*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor29/*/root/x_uint32*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  {  // /root/x_uint64
    static constexpr absl::string_view kOperatorName =
        "_G_Gmy_Rnamespace_G_GLoadFromProtoDescriptorBased_G_G_Froot_Fx_Ruint64";

    // Register QExpr operator.
    ASSIGN_OR_RETURN(
        auto qexpr_op, ::arolla::QExprOperatorFromFunction(
            LoadFromProtoDescriptorBasedFunctor30/*/root/x_uint64*/()));
    RETURN_IF_ERROR(
      ::arolla::OperatorRegistry::GetInstance()->RegisterOperator(
          kOperatorName,
          qexpr_op));

    // Register Expr operator.
    RETURN_IF_ERROR(
      ::arolla::expr::RegisterOperator(
              kOperatorName, arolla::operator_loader::BackendOperator::Make(
                kOperatorName,
                arolla::expr::ExprOperatorSignature::MakeArgsN(1),
                /*doc=*/kOperatorName,
                /*qtype_constraints=*/{},
                /*qtype_inference_expr=*/arolla::expr::Literal(
                    qexpr_op->signature()->output_type()
                )))
      .status());

    // Register QExpr metadata for codegen.
    ::arolla::QExprOperatorMetadata metadata;
    metadata.name = kOperatorName;
    metadata.build_details.build_target =
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set";
    metadata.build_details.op_class =
          R"FUNCTOR_NAME(my_namespace::LoadFromProtoDescriptorBasedFunctor30/*/root/x_uint64*/)FUNCTOR_NAME";
    ::arolla::OpClassDetails op_class_details;
    op_class_details.returns_status_or = false;
    op_class_details.accepts_context = false;
    metadata.build_details.op_class_details = op_class_details;
    metadata.build_details.hdrs = {
        "arolla/codegen/io/testing/test_descriptor_based_input_loader_operators_set.h"};
    metadata.build_details.deps = {
        "//arolla/codegen/io/testing:test_descriptor_based_input_loader_operators_set_lib"};
    metadata.input_qtypes = {kInputQtype};
    ::arolla::RegisterOperatorMetadataOrDie(std::move(metadata));
  }

  return absl::OkStatus();
}

AROLLA_INITIALIZER(.init_fn = RegisterIOOperators0);

}  // namespace
}  // namespace my_namespace
