from typing import Any, Callable, Iterable, SupportsBytes, SupportsFloat, SupportsIndex
from arolla.abc import abc as rl_abc

class MissingOptionalError(ValueError):
  pass

# go/keep-sorted start block=yes
ARRAY_EDGE: rl_abc.QType = ...
ARRAY_SHAPE: rl_abc.QType = ...
ARRAY_TO_SCALAR_EDGE: rl_abc.QType = ...
ARRAY_UNIT: rl_abc.QType = ...
DENSE_ARRAY_EDGE: rl_abc.QType = ...
DENSE_ARRAY_SHAPE: rl_abc.QType = ...
DENSE_ARRAY_TO_SCALAR_EDGE: rl_abc.QType = ...
OPTIONAL_SCALAR_SHAPE: rl_abc.QType = ...
SCALAR_SHAPE: rl_abc.QType = ...
SCALAR_TO_SCALAR_EDGE: rl_abc.QType = ...
# go/keep-sorted end

# go/keep-sorted start block=yes
_BooleanLike = Any
_BytesLike = SupportsBytes
_FloatLike = SupportsFloat | SupportsIndex
_IndexLike = SupportsIndex
_TextLike = Any
_UnitLike = Any
# go/keep-sorted end

_Buffer = Any  # TODO: Use collections.abc.Buffer from Python 3.12.

# go/keep-sorted start block=yes
def py_boolean(x: _BooleanLike | None, /) -> bool | None: ...
def py_bytes(x: _BytesLike | None, /) -> bytes | None: ...
def py_float(x: _FloatLike | None, /) -> float | None: ...
def py_index(x: _IndexLike | None, /) -> int | None: ...
def py_text(x: _TextLike | None, /) -> str | None: ...
def py_unit(x: _UnitLike | None, /) -> bool | None: ...
# go/keep-sorted end

# go/keep-sorted start block=yes
def boolean(x: _BooleanLike, /) -> rl_abc.AnyQValue: ...
def bytes(x: _BytesLike, /) -> rl_abc.AnyQValue: ...
def float32(x: _FloatLike, /) -> rl_abc.AnyQValue: ...
def float64(x: _FloatLike, /) -> rl_abc.AnyQValue: ...
def int32(x: _IndexLike, /) -> rl_abc.AnyQValue: ...
def int64(x: _IndexLike, /) -> rl_abc.AnyQValue: ...
def text(x: _TextLike, /) -> rl_abc.AnyQValue: ...
def uint64(x: _IndexLike, /) -> rl_abc.AnyQValue: ...
def unit() -> rl_abc.AnyQValue: ...
def weak_float(x: _FloatLike, /) -> rl_abc.AnyQValue: ...
# go/keep-sorted end

# go/keep-sorted start block=yes
def optional_boolean(x: _BooleanLike | None, /) -> rl_abc.AnyQValue: ...
def optional_bytes(x: _BytesLike | None, /) -> rl_abc.AnyQValue: ...
def optional_float32(x: _FloatLike | None, /) -> rl_abc.AnyQValue: ...
def optional_float64(x: _FloatLike | None, /) -> rl_abc.AnyQValue: ...
def optional_int32(x: _IndexLike | None, /) -> rl_abc.AnyQValue: ...
def optional_int64(x: _IndexLike | None, /) -> rl_abc.AnyQValue: ...
def optional_text(x: _TextLike | None, /) -> rl_abc.AnyQValue: ...
def optional_uint64(x: _IndexLike | None, /) -> rl_abc.AnyQValue: ...
def optional_unit(x: _UnitLike | None) -> rl_abc.AnyQValue: ...
def optional_weak_float(x: _FloatLike | None, /) -> rl_abc.AnyQValue: ...
# go/keep-sorted end

# go/keep-sorted start block=yes
def dense_array_boolean_from_values(
    values: Iterable[_BooleanLike | None], /
) -> rl_abc.AnyQValue: ...
def dense_array_bytes_from_values(
    values: Iterable[_BytesLike | None], /
) -> rl_abc.AnyQValue: ...
def dense_array_float32_from_values(
    values: Iterable[_FloatLike | None], /
) -> rl_abc.AnyQValue: ...
def dense_array_float64_from_values(
    values: Iterable[_FloatLike | None], /
) -> rl_abc.AnyQValue: ...
def dense_array_int32_from_values(
    values: Iterable[_IndexLike | None], /
) -> rl_abc.AnyQValue: ...
def dense_array_int64_from_values(
    values: Iterable[_IndexLike | None], /
) -> rl_abc.AnyQValue: ...
def dense_array_text_from_values(
    values: Iterable[_TextLike | None], /
) -> rl_abc.AnyQValue: ...
def dense_array_uint64_from_values(
    values: Iterable[_IndexLike | None], /
) -> rl_abc.AnyQValue: ...
def dense_array_unit_from_values(
    values: Iterable[_UnitLike], /
) -> rl_abc.AnyQValue: ...
def dense_array_weak_float_from_values(
    values: Iterable[_FloatLike | None], /
) -> rl_abc.AnyQValue: ...
# go/keep-sorted end

# go/keep-sorted start block=yes
def dense_array_boolean_from_values_buffer(
    buffer: _Buffer, /
) -> rl_abc.AnyQValue: ...
def dense_array_float32_from_values_buffer(
    buffer: _Buffer, /
) -> rl_abc.AnyQValue: ...
def dense_array_float64_from_values_buffer(
    buffer: _Buffer, /
) -> rl_abc.AnyQValue: ...
def dense_array_int32_from_values_buffer(
    buffer: _Buffer, /
) -> rl_abc.AnyQValue: ...
def dense_array_int64_from_values_buffer(
    buffer: _Buffer, /
) -> rl_abc.AnyQValue: ...
def dense_array_uint64_from_values_buffer(
    buffer: _Buffer, /
) -> rl_abc.AnyQValue: ...
def dense_array_weak_float_from_values_buffer(
    buffer: _Buffer, /
) -> rl_abc.AnyQValue: ...
# go/keep-sorted end

def get_array_item(
    array: rl_abc.QValue, i: _IndexLike, /
) -> rl_abc.AnyQValue: ...
def get_array_py_value(array: rl_abc.QValue, /) -> list[Any]: ...
def get_dense_array_memoryview(dense_array: rl_abc.QValue, /) -> memoryview: ...

# go/keep-sorted start block=yes newline_separated=yes
def get_namedtuple_field_index(
    qtype: rl_abc.QType, field_name: str, /
) -> int | None: ...

def get_namedtuple_field_names(qtype: rl_abc.QType, /) -> list[str]: ...

def get_nth(qvalue: rl_abc.QValue, n: int, /) -> rl_abc.AnyQValue: ...

def get_py_object_codec(value: rl_abc.QValue, /) -> bytes | None: ...

def get_py_object_data(value: rl_abc.QValue, /) -> bytes: ...

def internal_make_namedtuple_qtype(
    field_names: Iterable[str], tuple_qtype: rl_abc.QType, /
) -> rl_abc.QType: ...

def internal_make_sequence_qvalue(
    values: tuple[rl_abc.QValue, ...],
    value_qtype: rl_abc.QType | None = None,
    /,
) -> rl_abc.AnyQValue: ...

def internal_make_tuple_qtype(
    field_qtypes: Iterable[rl_abc.QType], /
) -> rl_abc.QType: ...

def internal_register_py_object_decoding_fn(
    decoding_fn: Callable[[bytes, bytes], Any] | None, /
) -> None: ...

def internal_register_py_object_encoding_fn(
    encoding_fn: Callable[[Any, bytes], bytes] | None, /
) -> None: ...

def is_dict_qtype(qtype: rl_abc.QType, /) -> bool: ...

def is_key_to_row_dict_qtype(qtype: rl_abc.QType, /) -> bool: ...

def is_namedtuple_qtype(qtype: rl_abc.QType, /) -> bool: ...

def is_sequence_qtype(qtype: rl_abc.QType, /) -> bool: ...

def is_tuple_qtype(qtype: rl_abc.QType, /) -> bool: ...

def make_dict_qtype(
    key_qtype: rl_abc.QType, value_qtype: rl_abc.QType, /
) -> rl_abc.QType: ...

def make_key_to_row_dict_qtype(key_qtype: rl_abc.QType, /) -> rl_abc.QType: ...

def make_qvalue_from_fields(
    compound_qtype: rl_abc.QType, field_qvalues: Iterable[rl_abc.QValue], /
) -> rl_abc.AnyQValue: ...

def make_sequence_qtype(value_qtype: rl_abc.QType, /) -> rl_abc.QType: ...

def make_sequence_qvalue(
    values: Iterable[rl_abc.QValue],
    /,
    value_qtype: rl_abc.QType | None = None,
) -> rl_abc.AnyQValue: ...

def py_object(
    object: Any, /, codec: bytes | None = None
) -> rl_abc.AnyQValue: ...

def py_object_from_data(data: bytes, codec: bytes, /) -> rl_abc.AnyQValue: ...

def unbox_py_object(value: rl_abc.QValue, /) -> Any: ...
# go/keep-sorted end
